group spark_init;




CHOICE_setters_body_child(sTasName, sName, sType, sNamePresent) ::= <<
FUNCTION <sTasName>_<sName>_get(val:<sTasName>) RETURN <sType>
IS --# hide <sTasName>_<sName>_get;
BEGIN
    RETURN val.<sName>;
END <sTasName>_<sName>_get;

FUNCTION <sTasName>_<sName>_set(itm:<sType>) RETURN <sTasName>
IS --# hide <sTasName>_<sName>_set;
BEGIN
    RETURN <sTasName>'(kind => <sNamePresent>, <sName> => itm);
END <sTasName>_<sName>_set;
>>


CHOICE_setters_body(sTasName, arrsChildren) ::= <<
FUNCTION <sTasName>_kind(val:<sTasName>) RETURN <sTasName>_selection 
IS --# hide <sTasName>_kind;
BEGIN
    return val.kind;
END <sTasName>_kind;

<arrsChildren; separator="\n">


>>



PrintTypeAssignment(sName, sInitBody, bContainsChoice) ::= <<
FUNCTION <sName>_Init return <sName>
IS <if(bContainsChoice)>--#hide <sName>_Init;<endif>
BEGIN
    RETURN <sInitBody>;
END <sName>_Init;
>>

/*
 *****************************************************************************************
               E Q U A L I T Y     F U N C T I O N S
 *****************************************************************************************
 */
PrimitiveEqual(p1,p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Integer(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Real(p1, p2) ::= <<
begin
    return (abs((<p1> - <p2>) / <p1>) \< 0.00001);
>>


isEqual_IA5String(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_NumericString(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_OctetString(p1, p2, bFixedSize, nFixedSize) ::= <<
<if(!bFixedSize)>
    subtype Slice is Natural range 1 .. <p1>.Length;
begin
    return (<p1>.Length = <p2>.Length and then <p1>.Data(Slice) = <p2>.Data(Slice));
<else>
begin
    return <p1> = <p2>;
<endif>	
>>


isEqual_NullType() ::= "return True;"


isEqual_BitString(p1,p2,bFixedSize,nFixedSize) ::= <<
<isEqual_OctetString(p1=p1,p2=p2, bFixedSize=bFixedSize, nFixedSize=nFixedSize)>
>>

isEqual_Boolean(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Enumerated(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_SequenceOf(p1,p2, i, bIsFixedSize, nFixedSize, sInnerType) ::= <<
<if(!bIsFixedSize)>
    subtype Slice is Natural range 1 .. <p1>.Length;
begin
    return (<p1>.Length = <p2>.Length and then (for all I in Slice => <p1>.Data(I) = <p2>.Data(I)));
<else>
begin
    return <p1> = <p2>;
<endif>	
>>


isEqual_Choice_Child(sCid, sInnerType) ::= <<
WHEN <sCid> =>
    <sInnerType>
>>

isEqual_Choice(p1,p2, arrsChildren, sTasName) ::= <<
begin
    if <p1>.kind /= <p2>.kind then
        return False;
    end if;
    case <sTasName>_kind(val1) is
        <arrsChildren; separator="\n">
    end case;
>>

isEqual_Sequence_Child(p1, p2, bIsOptional, sChName) ::= <<
<if(bIsOptional)>
(<p1>exist.<sChName> = <p2>exist.<sChName> and (<p1>exist.<sChName> and then <p1>.<sChName> = <p2>.<sChName> or else True))
<else>
<p1>.<sChName> = <p2>.<sChName>
<endif>
>>

isEqual_Sequence(p1, p2, arrsChildren) ::= <<
begin
    return <arrsChildren; separator=" and ">;
>>

isEqual_ReferenceType(sPtr1, sPtr2, sName) ::= <<
return <sPtr1> = <sPtr2>;
>>


PrintTypeAssignment_Equal(sName, sBody, arrsLocalVariables) ::= <<
function <sName>_Equal(val1, val2: in <sName>) return Boolean
is
<sBody>
end <sName>_Equal;
>>
