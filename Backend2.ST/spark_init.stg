group spark_init;




CHOICE_setters_body_child(sTasName, sName, sType, sNamePresent) ::= <<
FUNCTION <sTasName>_<sName>_get(val:<sTasName>) RETURN <sType>
IS --# hide <sTasName>_<sName>_get;
BEGIN
    RETURN val.<sName>;
END <sTasName>_<sName>_get;

FUNCTION <sTasName>_<sName>_set(itm:<sType>) RETURN <sTasName>
IS --# hide <sTasName>_<sName>_set;
BEGIN
    RETURN <sTasName>'(kind => <sNamePresent>, <sName> => itm);
END <sTasName>_<sName>_set;
>>


CHOICE_setters_body(sTasName, arrsChildren) ::= <<
FUNCTION <sTasName>_kind(val:<sTasName>) RETURN <sTasName>_selection 
IS --# hide <sTasName>_kind;
BEGIN
    return val.kind;
END <sTasName>_kind;

<arrsChildren; separator="\n">


>>



PrintTypeAssignment(sName, sInitBody, bContainsChoice) ::= <<
FUNCTION <sName>_Init return <sName>
IS <if(bContainsChoice)>--#hide <sName>_Init;<endif>
BEGIN
    RETURN <sInitBody>;
END <sName>_Init;
>>

/*
 *****************************************************************************************
               E Q U A L I T Y     F U N C T I O N S
 *****************************************************************************************
 */

PrimitiveEqual(p1,p2) ::= "RETURN <p1> = <p2>;"

PrintTypeAssignment_Equal(sName, sBody) ::= <<
FUNCTION <sName>_Equal(val1, val2: in <sName>) return Boolean
IS 
BEGIN
    <sBody>
END <sName>_Equal;
>>


isEqual_Integer(p1, p2) ::= "RETURN <p1> = <p2>;"

isEqual_Real(p1, p2) ::= <<
RETURN (abs((<p1> - <p2>) / <p1>) \< 0.00001);
>>

isEqual_IA5String(p1, p2) ::= "RETURN <p1> = <p2>;"

isEqual_NumericString(p1, p2) ::= "RETURN <p1> = <p2>;"

isEqual_OctetString(p1,p2, bFixedSize, nFixedSize) ::= <<
<if(!bFixedSize)>
IF <p1>.Length = <p2>.Length THEN
    FOR x in integer range 1 .. <p1>.Length LOOP
        IF INTEGER(<p1>.Data(x)) /= INTEGER(<p2>.Data(x)) THEN
            RETURN FALSE;
        END IF;
    END LOOP;
    RETURN TRUE;
ELSE
    RETURN FALSE;
END IF;

<else>
FOR x in integer range 1 .. <nFixedSize> LOOP
    IF INTEGER(<p1>.Data(x)) /= INTEGER(<p2>.Data(x)) THEN
        RETURN FALSE;
    END IF;
END LOOP;
RETURN TRUE;

<endif>	
>>

isEqual_NullType() ::= "return TRUE;"

isEqual_BitString(p1,p2,bFixedSize,nFixedSize) ::= <<
<isEqual_OctetString(p1=p1,p2=p2, bFixedSize=bFixedSize, nFixedSize=nFixedSize)>
>>

isEqual_Boolean(p1, p2) ::= "RETURN <p1> = <p2>;"

isEqual_Enumerated(p1, p2) ::= "<isEqual_Integer(p1=p1,p2=p2)>"

isEqual_SequenceOf(p1,p2, i, bIsFixedSize, nFixedSize, sInnerType) ::= <<
<if(!bIsFixedSize)>
IF (<p1>.Length /= <p2>.Length) THEN
    RETURN FALSE;
END IF;
<endif>
FOR <i> in integer range 1 .. <p1>.Length LOOP
    <sInnerType>
END LOOP;
>>

isEqual_Choice_Child(sCid, sInnerType) ::= <<
case <sCid>:
	<sInnerType>
	break;
>>

isEqual_Choice(p1,p2, arrsChildren) ::= <<
ret = (<p1>kind == <p2>kind);
if (ret) {
	switch(<p1>kind) 
	{
	<arrsChildren: {ch|<ch>}; separator="\n">
	default:
		ret = FALSE;    //COVERAGE_IGNORE
	}
}
>>

isEqual_Sequence_child(p1, p2, bIsOptional, sChName, sInnerType) ::= <<
<if(bIsOptional)>
ret = (<p1>exist.<sChName> == <p2>exist.<sChName>);
if (ret && <p1>exist.<sChName>) {
	<sInnerType>
}
<else>
<sInnerType>
<endif>
>>


isEqual_ReferenceType(sPtr1, sPtr2, sName) ::= <<
ret = <sName>_Equal(<sPtr1>, <sPtr2>);
>>