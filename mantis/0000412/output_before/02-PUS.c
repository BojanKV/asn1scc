/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "02-PUS.h"


#ifndef _MSC_VER
void TC_HEADER_SEQUENCE_FLAGS_Initialize(TC_HEADER_SEQUENCE_FLAGS* pVal)
{
    static TC_HEADER_SEQUENCE_FLAGS ret = 
        first_packet;
    *pVal = ret;
}
#endif

 
flag TC_HEADER_SEQUENCE_FLAGS_IsConstraintValid(const TC_HEADER_SEQUENCE_FLAGS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == first_packet) || (*pVal == continuation_packet)) || (*pVal == last_packet)) || (*pVal == stand_alone_packet));
	*pErrCode = ret ? 0 : ERR_TC_HEADER_SEQUENCE_FLAGS;

	return ret;
}

flag TC_HEADER_SEQUENCE_FLAGS_Equal(const TC_HEADER_SEQUENCE_FLAGS* pVal1, const TC_HEADER_SEQUENCE_FLAGS* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TC_HEADER_SEQUENCE_FLAGS_ACN_Encode(const TC_HEADER_SEQUENCE_FLAGS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    asn1SccSint intVal;

    ret = bCheckConstraints ? TC_HEADER_SEQUENCE_FLAGS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) { 
	        case first_packet:
	            intVal = 0;
	            break;
	        case continuation_packet:
	            intVal = 1;
	            break;
	        case last_packet:
	            intVal = 2;
	            break;
	        case stand_alone_packet:
	            intVal = 3;
	            break;
	    }
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, intVal, 0, 3);
    }

	return ret;
}

flag TC_HEADER_SEQUENCE_FLAGS_ACN_Decode(TC_HEADER_SEQUENCE_FLAGS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    asn1SccSint intVal;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &intVal, 0, 3);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    if (ret) {
        switch (intVal) {
            case 0:
                *pVal = first_packet;
                break;
            case 1:
                *pVal = continuation_packet;
                break;
            case 2:
                *pVal = last_packet;
                break;
            case 3:
                *pVal = stand_alone_packet;
                break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
            *pErrCode = ERR_INVALID_ENUM_VALUE;      //COVERAGE_IGNORE
        };
    }
    return ret;
}
#ifndef _MSC_VER
void SERVICE_TYPE_Initialize(SERVICE_TYPE* pVal)
{
    static SERVICE_TYPE ret = 
        0;
    *pVal = ret;
}
#endif

 
flag SERVICE_TYPE_IsConstraintValid(const SERVICE_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_SERVICE_TYPE;

	return ret;
}

flag SERVICE_TYPE_Equal(const SERVICE_TYPE* pVal1, const SERVICE_TYPE* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag SERVICE_TYPE_ACN_Encode(const SERVICE_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? SERVICE_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag SERVICE_TYPE_ACN_Decode(SERVICE_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void SERVICE_SUBTYPE_Initialize(SERVICE_SUBTYPE* pVal)
{
    static SERVICE_SUBTYPE ret = 
        0;
    *pVal = ret;
}
#endif

 
flag SERVICE_SUBTYPE_IsConstraintValid(const SERVICE_SUBTYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_SERVICE_SUBTYPE;

	return ret;
}

flag SERVICE_SUBTYPE_Equal(const SERVICE_SUBTYPE* pVal1, const SERVICE_SUBTYPE* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag SERVICE_SUBTYPE_ACN_Encode(const SERVICE_SUBTYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? SERVICE_SUBTYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag SERVICE_SUBTYPE_ACN_Decode(SERVICE_SUBTYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void DUMMY_PACKET_Initialize(DUMMY_PACKET* pVal)
{
    static DUMMY_PACKET ret = 
        0;
    *pVal = ret;
}
#endif

 
flag DUMMY_PACKET_IsConstraintValid(const DUMMY_PACKET* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_DUMMY_PACKET;

	return ret;
}

flag DUMMY_PACKET_Equal(const DUMMY_PACKET* pVal1, const DUMMY_PACKET* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag DUMMY_PACKET_ACN_Encode(const DUMMY_PACKET* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DUMMY_PACKET_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag DUMMY_PACKET_ACN_Decode(DUMMY_PACKET* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_ACCEPTANCE_REPORT_Initialize(TC_ACCEPTANCE_REPORT* pVal)
{
    static TC_ACCEPTANCE_REPORT ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_ACCEPTANCE_REPORT_IsConstraintValid(const TC_ACCEPTANCE_REPORT* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag TC_ACCEPTANCE_REPORT_Equal(const TC_ACCEPTANCE_REPORT* pVal1, const TC_ACCEPTANCE_REPORT* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag TC_ACCEPTANCE_REPORT_ACN_Encode(const TC_ACCEPTANCE_REPORT* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_ACCEPTANCE_REPORT_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag TC_ACCEPTANCE_REPORT_ACN_Decode(TC_ACCEPTANCE_REPORT* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void TC_ACCEPTANCE_REPORT_FAILURE_Initialize(TC_ACCEPTANCE_REPORT_FAILURE* pVal)
{
    static TC_ACCEPTANCE_REPORT_FAILURE ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_ACCEPTANCE_REPORT_FAILURE_IsConstraintValid(const TC_ACCEPTANCE_REPORT_FAILURE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag TC_ACCEPTANCE_REPORT_FAILURE_Equal(const TC_ACCEPTANCE_REPORT_FAILURE* pVal1, const TC_ACCEPTANCE_REPORT_FAILURE* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag TC_ACCEPTANCE_REPORT_FAILURE_ACN_Encode(const TC_ACCEPTANCE_REPORT_FAILURE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_ACCEPTANCE_REPORT_FAILURE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag TC_ACCEPTANCE_REPORT_FAILURE_ACN_Decode(TC_ACCEPTANCE_REPORT_FAILURE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void TC_EXECUTION_STARTED_Initialize(TC_EXECUTION_STARTED* pVal)
{
    static TC_EXECUTION_STARTED ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_EXECUTION_STARTED_IsConstraintValid(const TC_EXECUTION_STARTED* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag TC_EXECUTION_STARTED_Equal(const TC_EXECUTION_STARTED* pVal1, const TC_EXECUTION_STARTED* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag TC_EXECUTION_STARTED_ACN_Encode(const TC_EXECUTION_STARTED* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_EXECUTION_STARTED_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag TC_EXECUTION_STARTED_ACN_Decode(TC_EXECUTION_STARTED* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void TC_EXECUTION_PROGRESS_Initialize(TC_EXECUTION_PROGRESS* pVal)
{
    static TC_EXECUTION_PROGRESS ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_EXECUTION_PROGRESS_IsConstraintValid(const TC_EXECUTION_PROGRESS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag TC_EXECUTION_PROGRESS_Equal(const TC_EXECUTION_PROGRESS* pVal1, const TC_EXECUTION_PROGRESS* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag TC_EXECUTION_PROGRESS_ACN_Encode(const TC_EXECUTION_PROGRESS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_EXECUTION_PROGRESS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag TC_EXECUTION_PROGRESS_ACN_Decode(TC_EXECUTION_PROGRESS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void TC_EXECUTION_COMPLETE_Initialize(TC_EXECUTION_COMPLETE* pVal)
{
    static TC_EXECUTION_COMPLETE ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_EXECUTION_COMPLETE_IsConstraintValid(const TC_EXECUTION_COMPLETE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag TC_EXECUTION_COMPLETE_Equal(const TC_EXECUTION_COMPLETE* pVal1, const TC_EXECUTION_COMPLETE* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag TC_EXECUTION_COMPLETE_ACN_Encode(const TC_EXECUTION_COMPLETE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_EXECUTION_COMPLETE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag TC_EXECUTION_COMPLETE_ACN_Decode(TC_EXECUTION_COMPLETE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void TC_VERIFICATION_SERVICE_Initialize(TC_VERIFICATION_SERVICE* pVal)
{
    static TC_VERIFICATION_SERVICE ret = 
        {
            .kind = tcAcceptanceReport_PRESENT,
            .u = { .tcAcceptanceReport = 0}
        };
    *pVal = ret;
}
#endif

 
flag TC_VERIFICATION_SERVICE_IsConstraintValid(const TC_VERIFICATION_SERVICE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case tcAcceptanceReport_PRESENT :
	        ret = TC_ACCEPTANCE_REPORT_IsConstraintValid(&pVal->u.tcAcceptanceReport, pErrCode);
	        break;
	    case tcAcceptanceReportFailure_PRESENT :
	        ret = TC_ACCEPTANCE_REPORT_FAILURE_IsConstraintValid(&pVal->u.tcAcceptanceReportFailure, pErrCode);
	        break;
	    case tcExecutionStarted_PRESENT :
	        ret = TC_EXECUTION_STARTED_IsConstraintValid(&pVal->u.tcExecutionStarted, pErrCode);
	        break;
	    case tcExecutionProgress_PRESENT :
	        ret = TC_EXECUTION_PROGRESS_IsConstraintValid(&pVal->u.tcExecutionProgress, pErrCode);
	        break;
	    case tcExecutionComplete_PRESENT :
	        ret = TC_EXECUTION_COMPLETE_IsConstraintValid(&pVal->u.tcExecutionComplete, pErrCode);
	        break;
	    default:
		    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag TC_VERIFICATION_SERVICE_Equal(const TC_VERIFICATION_SERVICE* pVal1, const TC_VERIFICATION_SERVICE* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case tcAcceptanceReport_PRESENT:
			ret = TC_ACCEPTANCE_REPORT_Equal(&pVal1->u.tcAcceptanceReport, &pVal2->u.tcAcceptanceReport);
			break;
		case tcAcceptanceReportFailure_PRESENT:
			ret = TC_ACCEPTANCE_REPORT_FAILURE_Equal(&pVal1->u.tcAcceptanceReportFailure, &pVal2->u.tcAcceptanceReportFailure);
			break;
		case tcExecutionStarted_PRESENT:
			ret = TC_EXECUTION_STARTED_Equal(&pVal1->u.tcExecutionStarted, &pVal2->u.tcExecutionStarted);
			break;
		case tcExecutionProgress_PRESENT:
			ret = TC_EXECUTION_PROGRESS_Equal(&pVal1->u.tcExecutionProgress, &pVal2->u.tcExecutionProgress);
			break;
		case tcExecutionComplete_PRESENT:
			ret = TC_EXECUTION_COMPLETE_Equal(&pVal1->u.tcExecutionComplete, &pVal2->u.tcExecutionComplete);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag TC_VERIFICATION_SERVICE_ACN_Encode_update_sst(const TC_VERIFICATION_SERVICE* pVal, SERVICE_SUBTYPE* sst)
{
    flag ret = TRUE;

    switch (pVal->kind) {
        case tcAcceptanceReport_PRESENT:
        	*sst = 1; 
            break;
        case tcAcceptanceReportFailure_PRESENT:
        	*sst = 2; 
            break;
        case tcExecutionStarted_PRESENT:
        	*sst = 3; 
            break;
        case tcExecutionProgress_PRESENT:
        	*sst = 5; 
            break;
        case tcExecutionComplete_PRESENT:
        	*sst = 6; 
            break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
    }


    return ret;
}

flag TC_VERIFICATION_SERVICE_ACN_Encode(const TC_VERIFICATION_SERVICE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_VERIFICATION_SERVICE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case tcAcceptanceReport_PRESENT:
	    	ret = TC_ACCEPTANCE_REPORT_ACN_Encode(&pVal->u.tcAcceptanceReport, pBitStrm, pErrCode, FALSE);
	    	break;
	    case tcAcceptanceReportFailure_PRESENT:
	    	ret = TC_ACCEPTANCE_REPORT_FAILURE_ACN_Encode(&pVal->u.tcAcceptanceReportFailure, pBitStrm, pErrCode, FALSE);
	    	break;
	    case tcExecutionStarted_PRESENT:
	    	ret = TC_EXECUTION_STARTED_ACN_Encode(&pVal->u.tcExecutionStarted, pBitStrm, pErrCode, FALSE);
	    	break;
	    case tcExecutionProgress_PRESENT:
	    	ret = TC_EXECUTION_PROGRESS_ACN_Encode(&pVal->u.tcExecutionProgress, pBitStrm, pErrCode, FALSE);
	    	break;
	    case tcExecutionComplete_PRESENT:
	    	ret = TC_EXECUTION_COMPLETE_ACN_Encode(&pVal->u.tcExecutionComplete, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag TC_VERIFICATION_SERVICE_ACN_Decode(TC_VERIFICATION_SERVICE* pVal, BitStream* pBitStrm, int* pErrCode, SERVICE_SUBTYPE sst)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    if ((sst == 1)) {
        pVal->kind = tcAcceptanceReport_PRESENT;
        ret = TC_ACCEPTANCE_REPORT_ACN_Decode(&pVal->u.tcAcceptanceReport, pBitStrm, pErrCode);
    }
    else if ((sst == 2)) {
        pVal->kind = tcAcceptanceReportFailure_PRESENT;
        ret = TC_ACCEPTANCE_REPORT_FAILURE_ACN_Decode(&pVal->u.tcAcceptanceReportFailure, pBitStrm, pErrCode);
    }
    else if ((sst == 3)) {
        pVal->kind = tcExecutionStarted_PRESENT;
        ret = TC_EXECUTION_STARTED_ACN_Decode(&pVal->u.tcExecutionStarted, pBitStrm, pErrCode);
    }
    else if ((sst == 5)) {
        pVal->kind = tcExecutionProgress_PRESENT;
        ret = TC_EXECUTION_PROGRESS_ACN_Decode(&pVal->u.tcExecutionProgress, pBitStrm, pErrCode);
    }
    else if ((sst == 6)) {
        pVal->kind = tcExecutionComplete_PRESENT;
        ret = TC_EXECUTION_COMPLETE_ACN_Decode(&pVal->u.tcExecutionComplete, pBitStrm, pErrCode);
    }
    else {
        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
        ret = FALSE;                    //COVERAGE_IGNORE
    }
    return ret;
}
#ifndef _MSC_VER
void DISTRIBUTING_ON_OFF_COMMANDS_Initialize(DISTRIBUTING_ON_OFF_COMMANDS* pVal)
{
    static DISTRIBUTING_ON_OFF_COMMANDS ret = 
        0;
    *pVal = ret;
}
#endif

 
flag DISTRIBUTING_ON_OFF_COMMANDS_IsConstraintValid(const DISTRIBUTING_ON_OFF_COMMANDS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag DISTRIBUTING_ON_OFF_COMMANDS_Equal(const DISTRIBUTING_ON_OFF_COMMANDS* pVal1, const DISTRIBUTING_ON_OFF_COMMANDS* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag DISTRIBUTING_ON_OFF_COMMANDS_ACN_Encode(const DISTRIBUTING_ON_OFF_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DISTRIBUTING_ON_OFF_COMMANDS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag DISTRIBUTING_ON_OFF_COMMANDS_ACN_Decode(DISTRIBUTING_ON_OFF_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void DISTRIBUTING_REGISTER_LOAD_COMMANDS_Initialize(DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal)
{
    static DISTRIBUTING_REGISTER_LOAD_COMMANDS ret = 
        0;
    *pVal = ret;
}
#endif

 
flag DISTRIBUTING_REGISTER_LOAD_COMMANDS_IsConstraintValid(const DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag DISTRIBUTING_REGISTER_LOAD_COMMANDS_Equal(const DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal1, const DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag DISTRIBUTING_REGISTER_LOAD_COMMANDS_ACN_Encode(const DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DISTRIBUTING_REGISTER_LOAD_COMMANDS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag DISTRIBUTING_REGISTER_LOAD_COMMANDS_ACN_Decode(DISTRIBUTING_REGISTER_LOAD_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void DISTRIBUTING_CPDU_COMMANDS_Initialize(DISTRIBUTING_CPDU_COMMANDS* pVal)
{
    static DISTRIBUTING_CPDU_COMMANDS ret = 
        0;
    *pVal = ret;
}
#endif

 
flag DISTRIBUTING_CPDU_COMMANDS_IsConstraintValid(const DISTRIBUTING_CPDU_COMMANDS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = DUMMY_PACKET_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag DISTRIBUTING_CPDU_COMMANDS_Equal(const DISTRIBUTING_CPDU_COMMANDS* pVal1, const DISTRIBUTING_CPDU_COMMANDS* pVal2)
{
	flag ret=TRUE;
	
	ret = DUMMY_PACKET_Equal(pVal1, pVal2);

	return ret;
}

flag DISTRIBUTING_CPDU_COMMANDS_ACN_Encode(const DISTRIBUTING_CPDU_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DISTRIBUTING_CPDU_COMMANDS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DUMMY_PACKET_ACN_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag DISTRIBUTING_CPDU_COMMANDS_ACN_Decode(DISTRIBUTING_CPDU_COMMANDS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = DUMMY_PACKET_ACN_Decode(pVal, pBitStrm, pErrCode);
    return ret;
}
#ifndef _MSC_VER
void DEVICE_COMMAND_DISTTIBUTION_Initialize(DEVICE_COMMAND_DISTTIBUTION* pVal)
{
    static DEVICE_COMMAND_DISTTIBUTION ret = 
        {
            .kind = distributingOn_OffCommands_PRESENT,
            .u = { .distributingOn_OffCommands = 0}
        };
    *pVal = ret;
}
#endif

 
flag DEVICE_COMMAND_DISTTIBUTION_IsConstraintValid(const DEVICE_COMMAND_DISTTIBUTION* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case distributingOn_OffCommands_PRESENT :
	        ret = DISTRIBUTING_ON_OFF_COMMANDS_IsConstraintValid(&pVal->u.distributingOn_OffCommands, pErrCode);
	        break;
	    case distributingRegisterLoadCommands_PRESENT :
	        ret = DISTRIBUTING_REGISTER_LOAD_COMMANDS_IsConstraintValid(&pVal->u.distributingRegisterLoadCommands, pErrCode);
	        break;
	    case distributingCPDUCommands_PRESENT :
	        ret = DISTRIBUTING_CPDU_COMMANDS_IsConstraintValid(&pVal->u.distributingCPDUCommands, pErrCode);
	        break;
	    default:
		    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag DEVICE_COMMAND_DISTTIBUTION_Equal(const DEVICE_COMMAND_DISTTIBUTION* pVal1, const DEVICE_COMMAND_DISTTIBUTION* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case distributingOn_OffCommands_PRESENT:
			ret = DISTRIBUTING_ON_OFF_COMMANDS_Equal(&pVal1->u.distributingOn_OffCommands, &pVal2->u.distributingOn_OffCommands);
			break;
		case distributingRegisterLoadCommands_PRESENT:
			ret = DISTRIBUTING_REGISTER_LOAD_COMMANDS_Equal(&pVal1->u.distributingRegisterLoadCommands, &pVal2->u.distributingRegisterLoadCommands);
			break;
		case distributingCPDUCommands_PRESENT:
			ret = DISTRIBUTING_CPDU_COMMANDS_Equal(&pVal1->u.distributingCPDUCommands, &pVal2->u.distributingCPDUCommands);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag DEVICE_COMMAND_DISTTIBUTION_ACN_Encode_update_sst(const DEVICE_COMMAND_DISTTIBUTION* pVal, SERVICE_SUBTYPE* sst)
{
    flag ret = TRUE;

    switch (pVal->kind) {
        case distributingOn_OffCommands_PRESENT:
        	*sst = 1; 
            break;
        case distributingRegisterLoadCommands_PRESENT:
        	*sst = 2; 
            break;
        case distributingCPDUCommands_PRESENT:
        	*sst = 3; 
            break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
    }


    return ret;
}

flag DEVICE_COMMAND_DISTTIBUTION_ACN_Encode(const DEVICE_COMMAND_DISTTIBUTION* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? DEVICE_COMMAND_DISTTIBUTION_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case distributingOn_OffCommands_PRESENT:
	    	ret = DISTRIBUTING_ON_OFF_COMMANDS_ACN_Encode(&pVal->u.distributingOn_OffCommands, pBitStrm, pErrCode, FALSE);
	    	break;
	    case distributingRegisterLoadCommands_PRESENT:
	    	ret = DISTRIBUTING_REGISTER_LOAD_COMMANDS_ACN_Encode(&pVal->u.distributingRegisterLoadCommands, pBitStrm, pErrCode, FALSE);
	    	break;
	    case distributingCPDUCommands_PRESENT:
	    	ret = DISTRIBUTING_CPDU_COMMANDS_ACN_Encode(&pVal->u.distributingCPDUCommands, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag DEVICE_COMMAND_DISTTIBUTION_ACN_Decode(DEVICE_COMMAND_DISTTIBUTION* pVal, BitStream* pBitStrm, int* pErrCode, SERVICE_SUBTYPE sst)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    if ((sst == 1)) {
        pVal->kind = distributingOn_OffCommands_PRESENT;
        ret = DISTRIBUTING_ON_OFF_COMMANDS_ACN_Decode(&pVal->u.distributingOn_OffCommands, pBitStrm, pErrCode);
    }
    else if ((sst == 2)) {
        pVal->kind = distributingRegisterLoadCommands_PRESENT;
        ret = DISTRIBUTING_REGISTER_LOAD_COMMANDS_ACN_Decode(&pVal->u.distributingRegisterLoadCommands, pBitStrm, pErrCode);
    }
    else if ((sst == 3)) {
        pVal->kind = distributingCPDUCommands_PRESENT;
        ret = DISTRIBUTING_CPDU_COMMANDS_ACN_Decode(&pVal->u.distributingCPDUCommands, pBitStrm, pErrCode);
    }
    else {
        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
        ret = FALSE;                    //COVERAGE_IGNORE
    }
    return ret;
}
#ifndef _MSC_VER
void TM_DATA_SRC_Initialize(TM_DATA_SRC* pVal)
{
    static TM_DATA_SRC ret = 
        {
            .kind = tcVerification_PRESENT,
            .u = { .tcVerification = {
            .kind = tcAcceptanceReport_PRESENT,
            .u = { .tcAcceptanceReport = 0}
        }}
        };
    *pVal = ret;
}
#endif

 
flag TM_DATA_SRC_IsConstraintValid(const TM_DATA_SRC* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case tcVerification_PRESENT :
	        ret = TC_VERIFICATION_SERVICE_IsConstraintValid(&pVal->u.tcVerification, pErrCode);
	        break;
	    case deviceCommandDistribution_PRESENT :
	        ret = DEVICE_COMMAND_DISTTIBUTION_IsConstraintValid(&pVal->u.deviceCommandDistribution, pErrCode);
	        break;
	    default:
		    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag TM_DATA_SRC_Equal(const TM_DATA_SRC* pVal1, const TM_DATA_SRC* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case tcVerification_PRESENT:
			ret = TC_VERIFICATION_SERVICE_Equal(&pVal1->u.tcVerification, &pVal2->u.tcVerification);
			break;
		case deviceCommandDistribution_PRESENT:
			ret = DEVICE_COMMAND_DISTTIBUTION_Equal(&pVal1->u.deviceCommandDistribution, &pVal2->u.deviceCommandDistribution);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag TM_DATA_SRC_ACN_Encode_update_st(const TM_DATA_SRC* pVal, SERVICE_TYPE* st)
{
    flag ret = TRUE;

    switch (pVal->kind) {
        case tcVerification_PRESENT:
        	*st = 1; 
            break;
        case deviceCommandDistribution_PRESENT:
        	*st = 2; 
            break;
        default:
            ret = FALSE;                            //COVERAGE_IGNORE
    }


    return ret;
}

flag TM_DATA_SRC_ACN_Encode_update_sst(const TM_DATA_SRC* pVal, SERVICE_SUBTYPE* sst)
{
    flag ret = TRUE;

    switch (pVal->kind) {
    	case tcVerification_PRESENT:
    	    ret = TC_VERIFICATION_SERVICE_ACN_Encode_update_sst(&pVal->u.tcVerification, sst);
    	    break;
    	case deviceCommandDistribution_PRESENT:
    	    ret = DEVICE_COMMAND_DISTTIBUTION_ACN_Encode_update_sst(&pVal->u.deviceCommandDistribution, sst);
    	    break;
        default:
            ret = FALSE;                 //COVERAGE_IGNORE
    }

    return ret;
}

flag TM_DATA_SRC_ACN_Encode(const TM_DATA_SRC* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_DATA_SRC_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case tcVerification_PRESENT:
	    	ret = TC_VERIFICATION_SERVICE_ACN_Encode(&pVal->u.tcVerification, pBitStrm, pErrCode, FALSE);
	    	break;
	    case deviceCommandDistribution_PRESENT:
	    	ret = DEVICE_COMMAND_DISTTIBUTION_ACN_Encode(&pVal->u.deviceCommandDistribution, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag TM_DATA_SRC_ACN_Decode(TM_DATA_SRC* pVal, BitStream* pBitStrm, int* pErrCode, SERVICE_TYPE st, SERVICE_SUBTYPE sst)
{
    flag ret = TRUE;
    SERVICE_SUBTYPE DEVICE_COMMAND_DISTTIBUTION_sst;
    SERVICE_SUBTYPE TC_VERIFICATION_SERVICE_sst;
    *pErrCode = 0; ret = TRUE;
    if ((st == 1)) {
        pVal->kind = tcVerification_PRESENT;
        TC_VERIFICATION_SERVICE_sst = sst; // 3030
        ret = TC_VERIFICATION_SERVICE_ACN_Decode(&pVal->u.tcVerification, pBitStrm, pErrCode, TC_VERIFICATION_SERVICE_sst);
    }
    else if ((st == 2)) {
        pVal->kind = deviceCommandDistribution_PRESENT;
        DEVICE_COMMAND_DISTTIBUTION_sst = sst; // 3030
        ret = DEVICE_COMMAND_DISTTIBUTION_ACN_Decode(&pVal->u.deviceCommandDistribution, pBitStrm, pErrCode, DEVICE_COMMAND_DISTTIBUTION_sst);
    }
    else {
        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
        ret = FALSE;                    //COVERAGE_IGNORE
    }
    return ret;
}
#ifndef _MSC_VER
void MyPDU_Initialize(MyPDU* pVal)
{
    static MyPDU ret = 
        0;
    *pVal = ret;
}
#endif

 
flag MyPDU_IsConstraintValid(const MyPDU* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag MyPDU_Equal(const MyPDU* pVal1, const MyPDU* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag MyPDU_ACN_Encode(const MyPDU* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? MyPDU_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeUnConstraintWholeNumber(pBitStrm, *pVal);
    }

	return ret;
}

flag MyPDU_ACN_Decode(MyPDU* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, pVal);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_DATA_HEADER_absTime_Initialize(TM_DATA_HEADER_absTime* pVal)
{
    static TM_DATA_HEADER_absTime ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_DATA_HEADER_absTime_IsConstraintValid(const TM_DATA_HEADER_absTime* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal >= 0);
	*pErrCode = ret ? 0 : ERR_TM_DATA_HEADER_absTime;

	return ret;
}

flag TM_DATA_HEADER_absTime_Equal(const TM_DATA_HEADER_absTime* pVal1, const TM_DATA_HEADER_absTime* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_DATA_HEADER_absTime_ACN_Encode(const TM_DATA_HEADER_absTime* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_DATA_HEADER_absTime_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, *pVal);
    }

	return ret;
}

flag TM_DATA_HEADER_absTime_ACN_Decode(TM_DATA_HEADER_absTime* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(pBitStrm, pVal);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_DATA_HEADER_destinationID_Initialize(TM_DATA_HEADER_destinationID* pVal)
{
    static TM_DATA_HEADER_destinationID ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_DATA_HEADER_destinationID_IsConstraintValid(const TM_DATA_HEADER_destinationID* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 7);
	*pErrCode = ret ? 0 : ERR_TM_DATA_HEADER_destinationID;

	return ret;
}

flag TM_DATA_HEADER_destinationID_Equal(const TM_DATA_HEADER_destinationID* pVal1, const TM_DATA_HEADER_destinationID* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_DATA_HEADER_destinationID_ACN_Encode(const TM_DATA_HEADER_destinationID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_DATA_HEADER_destinationID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 7);
    }

	return ret;
}

flag TM_DATA_HEADER_destinationID_ACN_Decode(TM_DATA_HEADER_destinationID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 7);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_DATA_HEADER_packetSubcounter_Initialize(TM_DATA_HEADER_packetSubcounter* pVal)
{
    static TM_DATA_HEADER_packetSubcounter ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_DATA_HEADER_packetSubcounter_IsConstraintValid(const TM_DATA_HEADER_packetSubcounter* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_TM_DATA_HEADER_packetSubcounter;

	return ret;
}

flag TM_DATA_HEADER_packetSubcounter_Equal(const TM_DATA_HEADER_packetSubcounter* pVal1, const TM_DATA_HEADER_packetSubcounter* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_DATA_HEADER_packetSubcounter_ACN_Encode(const TM_DATA_HEADER_packetSubcounter* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_DATA_HEADER_packetSubcounter_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag TM_DATA_HEADER_packetSubcounter_ACN_Decode(TM_DATA_HEADER_packetSubcounter* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 255);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_DATA_HEADER_Initialize(TM_DATA_HEADER* pVal)
{
    static TM_DATA_HEADER ret = 
        {
            .packetSubcounter = 0,
            .destinationID = 0,
            .absTime = 0
        };
    *pVal = ret;
}
#endif

 
flag TM_DATA_HEADER_IsConstraintValid(const TM_DATA_HEADER* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TM_DATA_HEADER_packetSubcounter_IsConstraintValid(&pVal->packetSubcounter, pErrCode);
	if (ret) {
	    ret = TM_DATA_HEADER_destinationID_IsConstraintValid(&pVal->destinationID, pErrCode);
	    if (ret) {
	        ret = TM_DATA_HEADER_absTime_IsConstraintValid(&pVal->absTime, pErrCode);
	    
	    }
	}

	return ret;
}

flag TM_DATA_HEADER_Equal(const TM_DATA_HEADER* pVal1, const TM_DATA_HEADER* pVal2)
{
	flag ret=TRUE;
	
	ret = TM_DATA_HEADER_packetSubcounter_Equal(&pVal1->packetSubcounter, &pVal2->packetSubcounter);
	if (ret) {
	    ret = TM_DATA_HEADER_destinationID_Equal(&pVal1->destinationID, &pVal2->destinationID);
	    if (ret) {
	        ret = TM_DATA_HEADER_absTime_Equal(&pVal1->absTime, &pVal2->absTime);
	    
	    }
	}

	return ret;
}

flag TM_DATA_HEADER_ACN_Encode(const TM_DATA_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints, SERVICE_TYPE serviceType, SERVICE_SUBTYPE serviceSubtype)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_DATA_HEADER_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode spare1 */
	    {
	    	static byte tmp[] = {0x00};
	    	BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
	    if (ret) {
	        /*Encode tmPacketPUSVersionNumber */
	        {
	        	static byte tmp[] = {0x20};
	        	BitStream_AppendBits(pBitStrm, tmp, 3);
	        }
	        if (ret) {
	            /*Encode spare2 */
	            {
	            	static byte tmp[] = {0x00};
	            	BitStream_AppendBits(pBitStrm, tmp, 4);
	            }
	            if (ret) {
	                /*Encode serviceType */
	                ret = SERVICE_TYPE_ACN_Encode(&serviceType, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode serviceSubtype */
	                    ret = SERVICE_SUBTYPE_ACN_Encode(&serviceSubtype, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode packetSubcounter */
	                        ret = TM_DATA_HEADER_packetSubcounter_ACN_Encode(&pVal->packetSubcounter, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode destinationID */
	                            ret = TM_DATA_HEADER_destinationID_ACN_Encode(&pVal->destinationID, pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode absTime */
	                                ret = TM_DATA_HEADER_absTime_ACN_Encode(&pVal->absTime, pBitStrm, pErrCode, FALSE);

	                            }

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TM_DATA_HEADER_ACN_Decode(TM_DATA_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, SERVICE_TYPE* serviceType, SERVICE_SUBTYPE* serviceSubtype)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    /*Decode spare1 */
    {
    	static byte tmp[] = {0x00};
        flag dummy;
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &dummy);
        *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    }

    if (ret) {
        /*Decode tmPacketPUSVersionNumber */
        {
        	static byte tmp[] = {0x20};
            flag dummy;
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 3, &dummy);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
        }

        if (ret) {
            /*Decode spare2 */
            {
            	static byte tmp[] = {0x00};
                flag dummy;
            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 4, &dummy);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
            }

            if (ret) {
                /*Decode serviceType */
                ret = SERVICE_TYPE_ACN_Decode(serviceType, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode serviceSubtype */
                    ret = SERVICE_SUBTYPE_ACN_Decode(serviceSubtype, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode packetSubcounter */
                        ret = TM_DATA_HEADER_packetSubcounter_ACN_Decode(&pVal->packetSubcounter, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode destinationID */
                            ret = TM_DATA_HEADER_destinationID_ACN_Decode(&pVal->destinationID, pBitStrm, pErrCode);
                            if (ret) {
                                /*Decode absTime */
                                ret = TM_DATA_HEADER_absTime_ACN_Decode(&pVal->absTime, pBitStrm, pErrCode);

                            }

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TM_DATA_Initialize(TM_DATA* pVal)
{
    static TM_DATA ret = 
        {
            .header = {
                .packetSubcounter = 0,
                .destinationID = 0,
                .absTime = 0
            },
            .sourceData = {
                .kind = tcVerification_PRESENT,
                .u = { .tcVerification = {
                .kind = tcAcceptanceReport_PRESENT,
                .u = { .tcAcceptanceReport = 0}
            }}
            }
        };
    *pVal = ret;
}
#endif

 
flag TM_DATA_IsConstraintValid(const TM_DATA* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TM_DATA_HEADER_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    ret = TM_DATA_SRC_IsConstraintValid(&pVal->sourceData, pErrCode);
	
	}

	return ret;
}

flag TM_DATA_Equal(const TM_DATA* pVal1, const TM_DATA* pVal2)
{
	flag ret=TRUE;
	
	ret = TM_DATA_HEADER_Equal(&pVal1->header, &pVal2->header);
	if (ret) {
	    ret = TM_DATA_SRC_Equal(&pVal1->sourceData, &pVal2->sourceData);
	
	}

	return ret;
}

flag TM_DATA_ACN_Encode(const TM_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    SERVICE_TYPE TM_DATA_HEADER_serviceType;
    SERVICE_SUBTYPE TM_DATA_HEADER_serviceSubtype;
    SERVICE_SUBTYPE serviceSubtype;
    SERVICE_TYPE serviceType;

    ret = bCheckConstraints ? TM_DATA_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = TM_DATA_SRC_ACN_Encode_update_sst(&pVal->sourceData, &serviceSubtype);
	    if (ret) {
	        ret = (serviceSubtype >= 0 && serviceSubtype<=255);
	        *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	        if (ret) {
	            ret = TM_DATA_SRC_ACN_Encode_update_st(&pVal->sourceData, &serviceType);
	            if (ret) {
	                ret = (serviceType >= 0 && serviceType<=255);
	                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	                if (ret) {
	                    /*Encode header */
	                    TM_DATA_HEADER_serviceType = serviceType;// 3031
	                    TM_DATA_HEADER_serviceSubtype = serviceSubtype;// 3031
	                    ret = TM_DATA_HEADER_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE, TM_DATA_HEADER_serviceType, TM_DATA_HEADER_serviceSubtype);
	                    if (ret) {
	                        /*Encode sourceData */
	                        ret = TM_DATA_SRC_ACN_Encode(&pVal->sourceData, pBitStrm, pErrCode, FALSE);

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TM_DATA_ACN_Decode(TM_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    SERVICE_TYPE TM_DATA_SRC_st;
    SERVICE_SUBTYPE TM_DATA_SRC_sst;
    SERVICE_SUBTYPE serviceSubtype;
    SERVICE_TYPE serviceType;
    *pErrCode = 0; ret = TRUE;
    /*Decode header */


    ret = TM_DATA_HEADER_ACN_Decode(&pVal->header, pBitStrm, pErrCode, &serviceType, &serviceSubtype);
    if (ret) {
        if (ret) {
            if (ret) {
                if (ret) {
                    if (ret) {
                        /*Decode sourceData */
                        TM_DATA_SRC_st = serviceType; // 3030
                        TM_DATA_SRC_sst = serviceSubtype; // 3030
                        ret = TM_DATA_SRC_ACN_Decode(&pVal->sourceData, pBitStrm, pErrCode, TM_DATA_SRC_st, TM_DATA_SRC_sst);

                    }

                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TM_HEADER_packet_length_Initialize(TM_HEADER_packet_length* pVal)
{
    static TM_HEADER_packet_length ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_HEADER_packet_length_IsConstraintValid(const TM_HEADER_packet_length* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_TM_HEADER_packet_length;

	return ret;
}

flag TM_HEADER_packet_length_Equal(const TM_HEADER_packet_length* pVal1, const TM_HEADER_packet_length* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_HEADER_packet_length_ACN_Encode(const TM_HEADER_packet_length* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_HEADER_packet_length_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 65535);
    }

	return ret;
}

flag TM_HEADER_packet_length_ACN_Decode(TM_HEADER_packet_length* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 65535);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_HEADER_sequence_count_Initialize(TM_HEADER_sequence_count* pVal)
{
    static TM_HEADER_sequence_count ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_HEADER_sequence_count_IsConstraintValid(const TM_HEADER_sequence_count* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 16383);
	*pErrCode = ret ? 0 : ERR_TM_HEADER_sequence_count;

	return ret;
}

flag TM_HEADER_sequence_count_Equal(const TM_HEADER_sequence_count* pVal1, const TM_HEADER_sequence_count* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_HEADER_sequence_count_ACN_Encode(const TM_HEADER_sequence_count* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_HEADER_sequence_count_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 16383);
    }

	return ret;
}

flag TM_HEADER_sequence_count_ACN_Decode(TM_HEADER_sequence_count* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 16383);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_HEADER_applicationProcessID_Initialize(TM_HEADER_applicationProcessID* pVal)
{
    static TM_HEADER_applicationProcessID ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TM_HEADER_applicationProcessID_IsConstraintValid(const TM_HEADER_applicationProcessID* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 2047);
	*pErrCode = ret ? 0 : ERR_TM_HEADER_applicationProcessID;

	return ret;
}

flag TM_HEADER_applicationProcessID_Equal(const TM_HEADER_applicationProcessID* pVal1, const TM_HEADER_applicationProcessID* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TM_HEADER_applicationProcessID_ACN_Encode(const TM_HEADER_applicationProcessID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_HEADER_applicationProcessID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 2047);
    }

	return ret;
}

flag TM_HEADER_applicationProcessID_ACN_Decode(TM_HEADER_applicationProcessID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 2047);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TM_HEADER_Initialize(TM_HEADER* pVal)
{
    static TM_HEADER ret = 
        {
            .applicationProcessID = 0,
            .grouping_flags = first_packet,
            .sequence_count = 0,
            .packet_length = 0
        };
    *pVal = ret;
}
#endif

 
flag TM_HEADER_IsConstraintValid(const TM_HEADER* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TM_HEADER_applicationProcessID_IsConstraintValid(&pVal->applicationProcessID, pErrCode);
	if (ret) {
	    ret = TC_HEADER_SEQUENCE_FLAGS_IsConstraintValid(&pVal->grouping_flags, pErrCode);
	    if (ret) {
	        ret = TM_HEADER_sequence_count_IsConstraintValid(&pVal->sequence_count, pErrCode);
	        if (ret) {
	            ret = TM_HEADER_packet_length_IsConstraintValid(&pVal->packet_length, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag TM_HEADER_Equal(const TM_HEADER* pVal1, const TM_HEADER* pVal2)
{
	flag ret=TRUE;
	
	ret = TM_HEADER_applicationProcessID_Equal(&pVal1->applicationProcessID, &pVal2->applicationProcessID);
	if (ret) {
	    ret = TC_HEADER_SEQUENCE_FLAGS_Equal(&pVal1->grouping_flags, &pVal2->grouping_flags);
	    if (ret) {
	        ret = TM_HEADER_sequence_count_Equal(&pVal1->sequence_count, &pVal2->sequence_count);
	        if (ret) {
	            ret = TM_HEADER_packet_length_Equal(&pVal1->packet_length, &pVal2->packet_length);
	        
	        }
	    }
	}

	return ret;
}

flag TM_HEADER_ACN_Encode(const TM_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints, flag data_field_header_flag)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TM_HEADER_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode versionNumber */
	    {
	    	static byte tmp[] = {0x00};
	    	BitStream_AppendBits(pBitStrm, tmp, 3);
	    }
	    if (ret) {
	        /*Encode packet_type */
	        {
	        	static byte tmp[] = {0x00};
	        	BitStream_AppendBits(pBitStrm, tmp, 1);
	        }
	        if (ret) {
	            /*Encode data_field_header_flag */
	            {
	            	static byte true_data[] = {0x80};
	            	static byte false_data[] = {0x7F};
	                byte* tmp = data_field_header_flag ? true_data : false_data; 
	                BitStream_AppendBits(pBitStrm, tmp, 1);
	            }
	            if (ret) {
	                /*Encode applicationProcessID */
	                ret = TM_HEADER_applicationProcessID_ACN_Encode(&pVal->applicationProcessID, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode grouping_flags */
	                    ret = TC_HEADER_SEQUENCE_FLAGS_ACN_Encode(&pVal->grouping_flags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequence_count */
	                        ret = TM_HEADER_sequence_count_ACN_Encode(&pVal->sequence_count, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode packet_length */
	                            ret = TM_HEADER_packet_length_ACN_Encode(&pVal->packet_length, pBitStrm, pErrCode, FALSE);

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TM_HEADER_ACN_Decode(TM_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag* data_field_header_flag)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    /*Decode versionNumber */
    {
    	static byte tmp[] = {0x00};
        flag dummy;
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 3, &dummy);
        *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    }

    if (ret) {
        /*Decode packet_type */
        {
        	static byte tmp[] = {0x00};
            flag dummy;
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &dummy);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
        }

        if (ret) {
            /*Decode data_field_header_flag */
            {
            	static byte tmp[] = {0x80};
            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, data_field_header_flag);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
            }
            if (ret) {
                /*Decode applicationProcessID */
                ret = TM_HEADER_applicationProcessID_ACN_Decode(&pVal->applicationProcessID, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode grouping_flags */
                    ret = TC_HEADER_SEQUENCE_FLAGS_ACN_Decode(&pVal->grouping_flags, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sequence_count */
                        ret = TM_HEADER_sequence_count_ACN_Decode(&pVal->sequence_count, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode packet_length */
                            ret = TM_HEADER_packet_length_ACN_Decode(&pVal->packet_length, pBitStrm, pErrCode);

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TM_PACKET_Initialize(TM_PACKET* pVal)
{
    static TM_PACKET ret = 
        {
            .header = {
                .applicationProcessID = 0,
                .grouping_flags = first_packet,
                .sequence_count = 0,
                .packet_length = 0
            },
            .data = {
                .header = {
                    .packetSubcounter = 0,
                    .destinationID = 0,
                    .absTime = 0
                },
                .sourceData = {
                    .kind = tcVerification_PRESENT,
                    .u = { .tcVerification = {
                    .kind = tcAcceptanceReport_PRESENT,
                    .u = { .tcAcceptanceReport = 0}
                }}
                }
            },
            .exist = {
                .data = 1
            }
        };
    *pVal = ret;
}
#endif

 
flag TM_PACKET_IsConstraintValid(const TM_PACKET* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TM_HEADER_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    if (pVal->exist.data==1) {
	        ret = TM_DATA_IsConstraintValid(&pVal->data, pErrCode);
	    }
	
	}

	return ret;
}

flag TM_PACKET_Equal(const TM_PACKET* pVal1, const TM_PACKET* pVal2)
{
	flag ret=TRUE;
	
	ret = TM_HEADER_Equal(&pVal1->header, &pVal2->header);
	if (ret) {
	    ret = (pVal1->exist.data == pVal2->exist.data);
	    if (ret && pVal1->exist.data) {
	    	ret = TM_DATA_Equal(&pVal1->data, &pVal2->data);
	    }
	
	}

	return ret;
}

flag TM_PACKET_ACN_Encode(const TM_PACKET* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    flag TM_HEADER_data_field_header_flag;
    flag data_field_header_flag;

    ret = bCheckConstraints ? TM_PACKET_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    data_field_header_flag = (pVal->exist.data == 1);
	    if (ret) {
	        if (ret) {
	            /*Encode header */
	            TM_HEADER_data_field_header_flag = data_field_header_flag;// 3031
	            ret = TM_HEADER_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE, TM_HEADER_data_field_header_flag);
	            if (ret) {
	                /*Encode data */
	                if (pVal->exist.data) {
	                	ret = TM_DATA_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);
	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TM_PACKET_ACN_Decode(TM_PACKET* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    flag data_field_header_flag;
    *pErrCode = 0; ret = TRUE;
    /*Decode header */
    ret = TM_HEADER_ACN_Decode(&pVal->header, pBitStrm, pErrCode, &data_field_header_flag);
    if (ret) {
        if (ret) {
            pVal->exist.data = data_field_header_flag ? 1 : 0;
            if (ret) {
                /*Decode data */
                if (pVal->exist.data) {
                	ret = TM_DATA_ACN_Decode(&pVal->data, pBitStrm, pErrCode);
                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TC_DATA_HEADER_sourceID_Initialize(TC_DATA_HEADER_sourceID* pVal)
{
    static TC_DATA_HEADER_sourceID ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_DATA_HEADER_sourceID_IsConstraintValid(const TC_DATA_HEADER_sourceID* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 7);
	*pErrCode = ret ? 0 : ERR_TC_DATA_HEADER_sourceID;

	return ret;
}

flag TC_DATA_HEADER_sourceID_Equal(const TC_DATA_HEADER_sourceID* pVal1, const TC_DATA_HEADER_sourceID* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TC_DATA_HEADER_sourceID_ACN_Encode(const TC_DATA_HEADER_sourceID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_DATA_HEADER_sourceID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 7);
    }

	return ret;
}

flag TC_DATA_HEADER_sourceID_ACN_Decode(TC_DATA_HEADER_sourceID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 7);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_DATA_HEADER_ack_Initialize(TC_DATA_HEADER_ack* pVal)
{
    static TC_DATA_HEADER_ack ret = 
        {
            {
                0x00
            }
        };
    *pVal = ret;
}
#endif

 
flag TC_DATA_HEADER_ack_IsConstraintValid(const TC_DATA_HEADER_ack* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (4 == 4);
	*pErrCode = ret ? 0 : ERR_TC_DATA_HEADER_ack;

	return ret;
}

flag TC_DATA_HEADER_ack_Equal(const TC_DATA_HEADER_ack* pVal1, const TC_DATA_HEADER_ack* pVal2)
{
	flag ret=TRUE;
	
	ret = memcmp(pVal1->arr, pVal2->arr, 4/8) == 0;
	ret = ret && ((4 % 8) >0 ? (pVal1->arr[4/8]>>(8-4 % 8) == pVal2->arr[4/8]>>(8-4 % 8) ) : TRUE);


	return ret;
}

flag TC_DATA_HEADER_ack_ACN_Encode(const TC_DATA_HEADER_ack* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    int i1=0;

    ret = bCheckConstraints ? TC_DATA_HEADER_ack_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_AppendBits(pBitStrm, pVal->arr, 4);
    }

	return ret;
}

flag TC_DATA_HEADER_ack_ACN_Decode(TC_DATA_HEADER_ack* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    int i1=0;
    ret = BitStream_ReadBits(pBitStrm, pVal->arr, 4);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_DATA_HEADER_Initialize(TC_DATA_HEADER* pVal)
{
    static TC_DATA_HEADER ret = 
        {
            .cCSDSSecondaryHeaderFlag = FALSE,
            .ack = {
                {
                    0x00
                }
            },
            .serviceType = 0,
            .serviceSubtype = 0,
            .sourceID = 0
        };
    *pVal = ret;
}
#endif

 
flag TC_DATA_HEADER_IsConstraintValid(const TC_DATA_HEADER* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    ret = TC_DATA_HEADER_ack_IsConstraintValid(&pVal->ack, pErrCode);
	    if (ret) {
	        ret = SERVICE_TYPE_IsConstraintValid(&pVal->serviceType, pErrCode);
	        if (ret) {
	            ret = SERVICE_SUBTYPE_IsConstraintValid(&pVal->serviceSubtype, pErrCode);
	            if (ret) {
	                ret = TC_DATA_HEADER_sourceID_IsConstraintValid(&pVal->sourceID, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag TC_DATA_HEADER_Equal(const TC_DATA_HEADER* pVal1, const TC_DATA_HEADER* pVal2)
{
	flag ret=TRUE;
	
	ret = ( (pVal1->cCSDSSecondaryHeaderFlag && pVal2->cCSDSSecondaryHeaderFlag) || (!pVal1->cCSDSSecondaryHeaderFlag && !pVal2->cCSDSSecondaryHeaderFlag));
	if (ret) {
	    ret = TC_DATA_HEADER_ack_Equal(&pVal1->ack, &pVal2->ack);
	    if (ret) {
	        ret = SERVICE_TYPE_Equal(&pVal1->serviceType, &pVal2->serviceType);
	        if (ret) {
	            ret = SERVICE_SUBTYPE_Equal(&pVal1->serviceSubtype, &pVal2->serviceSubtype);
	            if (ret) {
	                ret = TC_DATA_HEADER_sourceID_Equal(&pVal1->sourceID, &pVal2->sourceID);
	            
	            }
	        }
	    }
	}

	return ret;
}

flag TC_DATA_HEADER_ACN_Encode(const TC_DATA_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_DATA_HEADER_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode cCSDSSecondaryHeaderFlag */
	    {
	    	static byte true_data[] = {0x80};
	    	static byte false_data[] = {0x7F};
	        byte* tmp = pVal->cCSDSSecondaryHeaderFlag ? true_data : false_data; 
	        BitStream_AppendBits(pBitStrm, tmp, 1);
	    }
	    if (ret) {
	        /*Encode tCPacketPUSVersionNumber */
	        {
	        	static byte tmp[] = {0x20};
	        	BitStream_AppendBits(pBitStrm, tmp, 3);
	        }
	        if (ret) {
	            /*Encode ack */
	            ret = TC_DATA_HEADER_ack_ACN_Encode(&pVal->ack, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode serviceType */
	                ret = SERVICE_TYPE_ACN_Encode(&pVal->serviceType, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode serviceSubtype */
	                    ret = SERVICE_SUBTYPE_ACN_Encode(&pVal->serviceSubtype, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sourceID */
	                        ret = TC_DATA_HEADER_sourceID_ACN_Encode(&pVal->sourceID, pBitStrm, pErrCode, FALSE);

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TC_DATA_HEADER_ACN_Decode(TC_DATA_HEADER* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    /*Decode cCSDSSecondaryHeaderFlag */
    {
    	static byte tmp[] = {0x80};
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &pVal->cCSDSSecondaryHeaderFlag);
        *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    }
    if (ret) {
        /*Decode tCPacketPUSVersionNumber */
        {
        	static byte tmp[] = {0x20};
            flag dummy;
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 3, &dummy);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
        }

        if (ret) {
            /*Decode ack */
            ret = TC_DATA_HEADER_ack_ACN_Decode(&pVal->ack, pBitStrm, pErrCode);
            if (ret) {
                /*Decode serviceType */
                ret = SERVICE_TYPE_ACN_Decode(&pVal->serviceType, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode serviceSubtype */
                    ret = SERVICE_SUBTYPE_ACN_Decode(&pVal->serviceSubtype, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sourceID */
                        ret = TC_DATA_HEADER_sourceID_ACN_Decode(&pVal->sourceID, pBitStrm, pErrCode);

                    }

                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TC_DATA_Initialize(TC_DATA* pVal)
{
    static TC_DATA ret = 
        {
            .header = {
                .cCSDSSecondaryHeaderFlag = FALSE,
                .ack = {
                    {
                        0x00
                    }
                },
                .serviceType = 0,
                .serviceSubtype = 0,
                .sourceID = 0
            },
            .exist = {
                .header = 1
            }
        };
    *pVal = ret;
}
#endif

 
flag TC_DATA_IsConstraintValid(const TC_DATA* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	if (pVal->exist.header==1) {
	    ret = TC_DATA_HEADER_IsConstraintValid(&pVal->header, pErrCode);
	}


	return ret;
}

flag TC_DATA_Equal(const TC_DATA* pVal1, const TC_DATA* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->exist.header == pVal2->exist.header);
	if (ret && pVal1->exist.header) {
		ret = TC_DATA_HEADER_Equal(&pVal1->header, &pVal2->header);
	}


	return ret;
}

flag TC_DATA_ACN_Encode_update_fldHeaderPresent(const TC_DATA* pVal, flag* fldHeaderPresent)
{
    flag ret = TRUE;

    *fldHeaderPresent = (pVal->exist.header == 1);


    return ret;
}

flag TC_DATA_ACN_Encode(const TC_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_DATA_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    if (ret) {
	        /*Encode header */
	        if (pVal->exist.header) {
	        	ret = TC_DATA_HEADER_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE);
	        }

	    }

    }

	return ret;
}

flag TC_DATA_ACN_Decode(TC_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag fldHeaderPresent)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    pVal->exist.header = fldHeaderPresent ? 1 : 0;
    if (ret) {
        /*Decode header */
        if (pVal->exist.header) {
        	ret = TC_DATA_HEADER_ACN_Decode(&pVal->header, pBitStrm, pErrCode);
        }

    }


    return ret;
}
#ifndef _MSC_VER
void TC_HEADER_packet_length_Initialize(TC_HEADER_packet_length* pVal)
{
    static TC_HEADER_packet_length ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_HEADER_packet_length_IsConstraintValid(const TC_HEADER_packet_length* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_TC_HEADER_packet_length;

	return ret;
}

flag TC_HEADER_packet_length_Equal(const TC_HEADER_packet_length* pVal1, const TC_HEADER_packet_length* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TC_HEADER_packet_length_ACN_Encode(const TC_HEADER_packet_length* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_HEADER_packet_length_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 65535);
    }

	return ret;
}

flag TC_HEADER_packet_length_ACN_Decode(TC_HEADER_packet_length* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 65535);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_HEADER_sequence_count_Initialize(TC_HEADER_sequence_count* pVal)
{
    static TC_HEADER_sequence_count ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_HEADER_sequence_count_IsConstraintValid(const TC_HEADER_sequence_count* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 16383);
	*pErrCode = ret ? 0 : ERR_TC_HEADER_sequence_count;

	return ret;
}

flag TC_HEADER_sequence_count_Equal(const TC_HEADER_sequence_count* pVal1, const TC_HEADER_sequence_count* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TC_HEADER_sequence_count_ACN_Encode(const TC_HEADER_sequence_count* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_HEADER_sequence_count_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 16383);
    }

	return ret;
}

flag TC_HEADER_sequence_count_ACN_Decode(TC_HEADER_sequence_count* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 16383);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_HEADER_applicationProcessID_Initialize(TC_HEADER_applicationProcessID* pVal)
{
    static TC_HEADER_applicationProcessID ret = 
        0;
    *pVal = ret;
}
#endif

 
flag TC_HEADER_applicationProcessID_IsConstraintValid(const TC_HEADER_applicationProcessID* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 2047);
	*pErrCode = ret ? 0 : ERR_TC_HEADER_applicationProcessID;

	return ret;
}

flag TC_HEADER_applicationProcessID_Equal(const TC_HEADER_applicationProcessID* pVal1, const TC_HEADER_applicationProcessID* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag TC_HEADER_applicationProcessID_ACN_Encode(const TC_HEADER_applicationProcessID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_HEADER_applicationProcessID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 2047);
    }

	return ret;
}

flag TC_HEADER_applicationProcessID_ACN_Decode(TC_HEADER_applicationProcessID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 2047);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    return ret;
}
#ifndef _MSC_VER
void TC_HEADER_Initialize(TC_HEADER* pVal)
{
    static TC_HEADER ret = 
        {
            .applicationProcessID = 0,
            .sequence_flags = first_packet,
            .sequence_count = 0,
            .packet_length = 0
        };
    *pVal = ret;
}
#endif

 
flag TC_HEADER_IsConstraintValid(const TC_HEADER* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TC_HEADER_applicationProcessID_IsConstraintValid(&pVal->applicationProcessID, pErrCode);
	if (ret) {
	    ret = TC_HEADER_SEQUENCE_FLAGS_IsConstraintValid(&pVal->sequence_flags, pErrCode);
	    if (ret) {
	        ret = TC_HEADER_sequence_count_IsConstraintValid(&pVal->sequence_count, pErrCode);
	        if (ret) {
	            ret = TC_HEADER_packet_length_IsConstraintValid(&pVal->packet_length, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag TC_HEADER_Equal(const TC_HEADER* pVal1, const TC_HEADER* pVal2)
{
	flag ret=TRUE;
	
	ret = TC_HEADER_applicationProcessID_Equal(&pVal1->applicationProcessID, &pVal2->applicationProcessID);
	if (ret) {
	    ret = TC_HEADER_SEQUENCE_FLAGS_Equal(&pVal1->sequence_flags, &pVal2->sequence_flags);
	    if (ret) {
	        ret = TC_HEADER_sequence_count_Equal(&pVal1->sequence_count, &pVal2->sequence_count);
	        if (ret) {
	            ret = TC_HEADER_packet_length_Equal(&pVal1->packet_length, &pVal2->packet_length);
	        
	        }
	    }
	}

	return ret;
}

flag TC_HEADER_ACN_Encode(const TC_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints, flag data_field_header_flag)
{
    flag ret = TRUE;

    ret = bCheckConstraints ? TC_HEADER_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode versionNumber */
	    {
	    	static byte tmp[] = {0x00};
	    	BitStream_AppendBits(pBitStrm, tmp, 3);
	    }
	    if (ret) {
	        /*Encode packet_type */
	        {
	        	static byte tmp[] = {0x80};
	        	BitStream_AppendBits(pBitStrm, tmp, 1);
	        }
	        if (ret) {
	            /*Encode data_field_header_flag */
	            {
	            	static byte true_data[] = {0x80};
	            	static byte false_data[] = {0x7F};
	                byte* tmp = data_field_header_flag ? true_data : false_data; 
	                BitStream_AppendBits(pBitStrm, tmp, 1);
	            }
	            if (ret) {
	                /*Encode applicationProcessID */
	                ret = TC_HEADER_applicationProcessID_ACN_Encode(&pVal->applicationProcessID, pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode sequence_flags */
	                    ret = TC_HEADER_SEQUENCE_FLAGS_ACN_Encode(&pVal->sequence_flags, pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode sequence_count */
	                        ret = TC_HEADER_sequence_count_ACN_Encode(&pVal->sequence_count, pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode packet_length */
	                            ret = TC_HEADER_packet_length_ACN_Encode(&pVal->packet_length, pBitStrm, pErrCode, FALSE);

	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag TC_HEADER_ACN_Decode(TC_HEADER* pVal, BitStream* pBitStrm, int* pErrCode, flag* data_field_header_flag)
{
    flag ret = TRUE;
    *pErrCode = 0; ret = TRUE;
    /*Decode versionNumber */
    {
    	static byte tmp[] = {0x00};
        flag dummy;
    	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 3, &dummy);
        *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    }

    if (ret) {
        /*Decode packet_type */
        {
        	static byte tmp[] = {0x80};
            flag dummy;
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &dummy);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
        }

        if (ret) {
            /*Decode data_field_header_flag */
            {
            	static byte tmp[] = {0x80};
            	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, data_field_header_flag);
                *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
            }
            if (ret) {
                /*Decode applicationProcessID */
                ret = TC_HEADER_applicationProcessID_ACN_Decode(&pVal->applicationProcessID, pBitStrm, pErrCode);
                if (ret) {
                    /*Decode sequence_flags */
                    ret = TC_HEADER_SEQUENCE_FLAGS_ACN_Decode(&pVal->sequence_flags, pBitStrm, pErrCode);
                    if (ret) {
                        /*Decode sequence_count */
                        ret = TC_HEADER_sequence_count_ACN_Decode(&pVal->sequence_count, pBitStrm, pErrCode);
                        if (ret) {
                            /*Decode packet_length */
                            ret = TC_HEADER_packet_length_ACN_Decode(&pVal->packet_length, pBitStrm, pErrCode);

                        }

                    }

                }

            }

        }

    }


    return ret;
}
#ifndef _MSC_VER
void TC_PACKET_Initialize(TC_PACKET* pVal)
{
    static TC_PACKET ret = 
        {
            .header = {
                .applicationProcessID = 0,
                .sequence_flags = first_packet,
                .sequence_count = 0,
                .packet_length = 0
            },
            .data = {
                .header = {
                    .cCSDSSecondaryHeaderFlag = FALSE,
                    .ack = {
                        {
                            0x00
                        }
                    },
                    .serviceType = 0,
                    .serviceSubtype = 0,
                    .sourceID = 0
                },
                .exist = {
                    .header = 1
                }
            }
        };
    *pVal = ret;
}
#endif

 
flag TC_PACKET_IsConstraintValid(const TC_PACKET* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TC_HEADER_IsConstraintValid(&pVal->header, pErrCode);
	if (ret) {
	    ret = TC_DATA_IsConstraintValid(&pVal->data, pErrCode);
	
	}

	return ret;
}

flag TC_PACKET_Equal(const TC_PACKET* pVal1, const TC_PACKET* pVal2)
{
	flag ret=TRUE;
	
	ret = TC_HEADER_Equal(&pVal1->header, &pVal2->header);
	if (ret) {
	    ret = TC_DATA_Equal(&pVal1->data, &pVal2->data);
	
	}

	return ret;
}

flag TC_PACKET_ACN_Encode(const TC_PACKET* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    flag TC_HEADER_data_field_header_flag;
    flag data_field_header_flag;

    ret = bCheckConstraints ? TC_PACKET_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = TC_DATA_ACN_Encode_update_fldHeaderPresent(&pVal->data, &data_field_header_flag);
	    if (ret) {
	        /*Encode header */
	        TC_HEADER_data_field_header_flag = data_field_header_flag;// 3031
	        ret = TC_HEADER_ACN_Encode(&pVal->header, pBitStrm, pErrCode, FALSE, TC_HEADER_data_field_header_flag);
	        if (ret) {
	            /*Encode data */
	            ret = TC_DATA_ACN_Encode(&pVal->data, pBitStrm, pErrCode, FALSE);

	        }

	    }

    }

	return ret;
}

flag TC_PACKET_ACN_Decode(TC_PACKET* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    flag TC_DATA_fldHeaderPresent;
    flag data_field_header_flag;
    *pErrCode = 0; ret = TRUE;
    /*Decode header */
    ret = TC_HEADER_ACN_Decode(&pVal->header, pBitStrm, pErrCode, &data_field_header_flag);
    if (ret) {
        if (ret) {
            /*Decode data */
            TC_DATA_fldHeaderPresent = data_field_header_flag; // 3030
            ret = TC_DATA_ACN_Decode(&pVal->data, pBitStrm, pErrCode, TC_DATA_fldHeaderPresent);

        }

    }


    return ret;
}
#ifndef _MSC_VER
void MySeq_Initialize(MySeq* pVal)
{
    static MySeq ret = 
        {
            .alpha = 0,
            .gamma = 0.000000E+000,
            .exist = {
                .gamma = 1
            }
        };
    *pVal = ret;
}
#endif

 
flag MySeq_IsConstraintValid(const MySeq* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;
	if (ret) {
	    if (pVal->exist.gamma==1) {
	        ret = TRUE; *pErrCode = 0;
	    }
	
	}

	return ret;
}

flag MySeq_Equal(const MySeq* pVal1, const MySeq* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->alpha == pVal2->alpha);
	if (ret) {
	    ret = (pVal1->exist.gamma == pVal2->exist.gamma);
	    if (ret && pVal1->exist.gamma) {
	    	ret = pVal1->gamma == 0.0 ? pVal2->gamma ==0.0 : (fabs((pVal1->gamma - pVal2->gamma) / pVal1->gamma) < 0.00001);
	    }
	
	}

	return ret;
}

flag MySeq_ACN_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    flag beta;
    flag MySeq_beta_0;

    ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    if (ret) {
	        /*Encode alpha */
	        BitStream_EncodeUnConstraintWholeNumber(pBitStrm, pVal->alpha);
	        if (ret) {
	            MySeq_beta_0 = (pVal->exist.gamma == 1);
	            if (ret) {
	                beta = MySeq_beta_0; // 23945
	                if (ret) {
	                    /*Encode beta */
	                    {
	                    	static byte true_data[] = {0x80};
	                    	static byte false_data[] = {0x7F};
	                        byte* tmp = beta ? true_data : false_data; 
	                        BitStream_AppendBits(pBitStrm, tmp, 1);
	                    }
	                    if (ret) {
	                        /*Encode gamma */
	                        if (pVal->exist.gamma) {
	                        	Acn_Enc_Real_IEEE754_64_big_endian(pBitStrm, pVal->gamma);
	                        }

	                    }

	                }

	            }

	        }

	    }

    }

	return ret;
}

flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
    flag beta;
    *pErrCode = 0; ret = TRUE;
    /*Decode alpha */
    ret = BitStream_DecodeUnConstraintWholeNumber(pBitStrm, &pVal->alpha);
    *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
    if (ret) {
        /*Decode beta */
        {
        	static byte tmp[] = {0x80};
        	ret = BitStream_ReadBitPattern(pBitStrm, tmp, 1, &beta);
            *pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
        }
        if (ret) {
            pVal->exist.gamma = beta ? 1 : 0;
            if (ret) {
                /*Decode gamma */
                if (pVal->exist.gamma) {
                	ret = Acn_Dec_Real_IEEE754_64_big_endian(pBitStrm, &pVal->gamma);
                	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
                }

            }

        }

    }


    return ret;
}

const MyPDU pdu1 = 0;
