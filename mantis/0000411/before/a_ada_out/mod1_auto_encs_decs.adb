-- Code automatically generated by asn1scc tool
with Interfaces;
use type Interfaces.Unsigned_8;
with adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
WITH MOD1; USE MOD1;
use type MOD1.RGBCOLORS;
use type MOD1.CH1;
PACKAGE BODY MOD1_auto_encs_decs 
IS 

FUNCTION RGBCOLORS_uPER_enc_dec(val:MOD1.RGBCOLORS) RETURN adaasn1rtl.TEST_CASE_RESULT
IS
    decodedPDU  : MOD1.RGBCOLORS;
    stream      : MOD1.RGBCOLORS_uPER_Stream;
    result      : adaasn1rtl.ASN1_RESULT;
    ret         : adaasn1rtl.TEST_CASE_RESULT;
BEGIN
    -- Check value against ASN.1 constraints
    result := MOD1.RGBCOLORS_IsConstraintValid(val);
    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
    IF result.Success THEN
        -- Encode value
        MOD1.RGBCOLORS_uPER_Encode(val, stream, result);
        ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
        IF result.Success THEN
            -- Decode value
            --at this point stream contains the uPER data
            MOD1.RGBCOLORS_uPER_Decode(decodedPDU, stream, result);
            ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
            IF result.Success THEN
                -- validate decoded data
                result := MOD1.RGBCOLORS_IsConstraintValid(decodedPDU);
                ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
                IF result.Success THEN
                    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_EQUAL, Success => RGBCOLORS_Equal(val, decodedPDU), ErrorCode => result.ErrorCode);

                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END RGBCOLORS_uPER_enc_dec;

FUNCTION CH1_uPER_enc_dec(val:MOD1.CH1) RETURN adaasn1rtl.TEST_CASE_RESULT
IS
    decodedPDU  : MOD1.CH1;
    stream      : MOD1.CH1_uPER_Stream;
    result      : adaasn1rtl.ASN1_RESULT;
    ret         : adaasn1rtl.TEST_CASE_RESULT;
BEGIN
    -- Check value against ASN.1 constraints
    result := MOD1.CH1_IsConstraintValid(val);
    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
    IF result.Success THEN
        -- Encode value
        MOD1.CH1_uPER_Encode(val, stream, result);
        ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
        IF result.Success THEN
            -- Decode value
            --at this point stream contains the uPER data
            MOD1.CH1_uPER_Decode(decodedPDU, stream, result);
            ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
            IF result.Success THEN
                -- validate decoded data
                result := MOD1.CH1_IsConstraintValid(decodedPDU);
                ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
                IF result.Success THEN
                    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_EQUAL, Success => CH1_Equal(val, decodedPDU), ErrorCode => result.ErrorCode);

                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END CH1_uPER_enc_dec;

FUNCTION CH1_left_uPER_enc_dec(val:MOD1.CH1_left) RETURN adaasn1rtl.TEST_CASE_RESULT
IS
    decodedPDU  : MOD1.CH1_left;
    stream      : MOD1.CH1_left_uPER_Stream;
    result      : adaasn1rtl.ASN1_RESULT;
    ret         : adaasn1rtl.TEST_CASE_RESULT;
BEGIN
    -- Check value against ASN.1 constraints
    result := MOD1.CH1_left_IsConstraintValid(val);
    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
    IF result.Success THEN
        -- Encode value
        MOD1.CH1_left_uPER_Encode(val, stream, result);
        ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
        IF result.Success THEN
            -- Decode value
            --at this point stream contains the uPER data
            MOD1.CH1_left_uPER_Decode(decodedPDU, stream, result);
            ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
            IF result.Success THEN
                -- validate decoded data
                result := MOD1.CH1_left_IsConstraintValid(decodedPDU);
                ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
                IF result.Success THEN
                    ret := adaasn1rtl.TEST_CASE_RESULT'(Step => adaasn1rtl.TC_EQUAL, Success => CH1_left_Equal(val, decodedPDU), ErrorCode => result.ErrorCode);

                END IF;
            END IF;
        END IF;
    END IF;
    RETURN ret;
END CH1_left_uPER_enc_dec;

END MOD1_auto_encs_decs;