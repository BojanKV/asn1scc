/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "b.h"


#ifndef _MSC_VER
void RGBCOLORS_Initialize(RGBCOLORS* pVal)
{
    static RGBCOLORS ret = 
        RGBCOLORS_red;
    *pVal = ret;
}
#endif

 
flag RGBCOLORS_IsConstraintValid(const RGBCOLORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == RGBCOLORS_red) || (*pVal == RGBCOLORS_green)) || (*pVal == RGBCOLORS_blue));
	*pErrCode = ret ? 0 : ERR_RGBCOLORS;

	return ret;
}

flag RGBCOLORS_Equal(const RGBCOLORS* pVal1, const RGBCOLORS* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag RGBCOLORS_Encode(const RGBCOLORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RGBCOLORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case RGBCOLORS_red:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case RGBCOLORS_green:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case RGBCOLORS_blue:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag RGBCOLORS_Decode(RGBCOLORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435457;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = RGBCOLORS_red;
	            break;
	        case 1: 
	            *pVal = RGBCOLORS_green;
	            break;
	        case 2: 
	            *pVal = RGBCOLORS_blue;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void OTHERCOLORS_Initialize(OTHERCOLORS* pVal)
{
    static OTHERCOLORS ret = 
        OTHERCOLORS_red;
    *pVal = ret;
}
#endif

 
flag OTHERCOLORS_IsConstraintValid(const OTHERCOLORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == OTHERCOLORS_red) || (*pVal == OTHERCOLORS_cyan)) || (*pVal == OTHERCOLORS_magenta));
	*pErrCode = ret ? 0 : ERR_OTHERCOLORS;

	return ret;
}

flag OTHERCOLORS_Equal(const OTHERCOLORS* pVal1, const OTHERCOLORS* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag OTHERCOLORS_Encode(const OTHERCOLORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? OTHERCOLORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case OTHERCOLORS_red:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case OTHERCOLORS_cyan:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case OTHERCOLORS_magenta:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741827; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag OTHERCOLORS_Decode(OTHERCOLORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435458;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = OTHERCOLORS_red;
	            break;
	        case 1: 
	            *pVal = OTHERCOLORS_cyan;
	            break;
	        case 2: 
	            *pVal = OTHERCOLORS_magenta;
	            break;
	        default:
		        *pErrCode = 1073741828;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void CH2_left_Initialize(CH2_left* pVal)
{
    static CH2_left ret = 
        1;
    *pVal = ret;
}
#endif

 
flag CH2_left_IsConstraintValid(const CH2_left* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= *pVal && *pVal <= 10);
	*pErrCode = ret ? 0 : ERR_CH2_left;

	return ret;
}

flag CH2_left_Equal(const CH2_left* pVal1, const CH2_left* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag CH2_left_Encode(const CH2_left* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH2_left_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 1, 10);
    }

	return ret;
}

flag CH2_left_Decode(CH2_left* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 1, 10);
	*pErrCode = ret ? 0 : 268435459;

	return ret;
}
#ifndef _MSC_VER
void CH2_Initialize(CH2* pVal)
{
    static CH2 ret = 
        {
            .kind = CH2_left_PRESENT,
            .u = { .left = 1}
        };
    *pVal = ret;
}
#endif

 
flag CH2_IsConstraintValid(const CH2* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case CH2_left_PRESENT :
	        ret = CH2_left_IsConstraintValid(&pVal->u.left, pErrCode);
	        break;
	    case CH2_center_PRESENT :
	        ret = OTHERCOLORS_IsConstraintValid(&pVal->u.center, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag CH2_Equal(const CH2* pVal1, const CH2* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case CH2_left_PRESENT:
			ret = CH2_left_Equal(&pVal1->u.left, &pVal2->u.left);
			break;
		case CH2_center_PRESENT:
			ret = OTHERCOLORS_Equal(&pVal1->u.center, &pVal2->u.center);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag CH2_Encode(const CH2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case CH2_left_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = CH2_left_Encode(&pVal->u.left, pBitStrm, pErrCode, FALSE);
	    	break;
	    case CH2_center_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = OTHERCOLORS_Encode(&pVal->u.center, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag CH2_Decode(CH2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435460;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = CH2_left_PRESENT;
	    	ret = CH2_left_Decode(&pVal->u.left, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = CH2_center_PRESENT;
	    	ret = OTHERCOLORS_Decode(&pVal->u.center, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void CH1_left_Initialize(CH1_left* pVal)
{
    static CH1_left ret = 
        1;
    *pVal = ret;
}
#endif

 
flag CH1_left_IsConstraintValid(const CH1_left* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= *pVal && *pVal <= 10);
	*pErrCode = ret ? 0 : ERR_CH1_left;

	return ret;
}

flag CH1_left_Equal(const CH1_left* pVal1, const CH1_left* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag CH1_left_Encode(const CH1_left* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH1_left_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 1, 10);
    }

	return ret;
}

flag CH1_left_Decode(CH1_left* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 1, 10);
	*pErrCode = ret ? 0 : 268435461;

	return ret;
}
#ifndef _MSC_VER
void CH1_Initialize(CH1* pVal)
{
    static CH1 ret = 
        {
            .kind = CH1_left_PRESENT,
            .u = { .left = 1}
        };
    *pVal = ret;
}
#endif

 
flag CH1_IsConstraintValid(const CH1* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case CH1_left_PRESENT :
	        ret = CH1_left_IsConstraintValid(&pVal->u.left, pErrCode);
	        break;
	    case CH1_right_PRESENT :
	        ret = RGBCOLORS_IsConstraintValid(&pVal->u.right, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306372;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag CH1_Equal(const CH1* pVal1, const CH1* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case CH1_left_PRESENT:
			ret = CH1_left_Equal(&pVal1->u.left, &pVal2->u.left);
			break;
		case CH1_right_PRESENT:
			ret = RGBCOLORS_Equal(&pVal1->u.right, &pVal2->u.right);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag CH1_Encode(const CH1* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH1_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case CH1_left_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = CH1_left_Encode(&pVal->u.left, pBitStrm, pErrCode, FALSE);
	    	break;
	    case CH1_right_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = RGBCOLORS_Encode(&pVal->u.right, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306373;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag CH1_Decode(CH1* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435462;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = CH1_left_PRESENT;
	    	ret = CH1_left_Decode(&pVal->u.left, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = CH1_right_PRESENT;
	    	ret = RGBCOLORS_Decode(&pVal->u.right, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306374;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

