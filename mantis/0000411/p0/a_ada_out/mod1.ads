-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit adaasn1rtl;


PACKAGE MOD1
IS


-----------------------------------------------------------RGBCOLORS-------------------------------------------------------------
SUBTYPE RGBCOLORS_index_range is integer range 0..2;
TYPE RGBCOLORS IS (red, green, blue);
for RGBCOLORS use
    (red => 0, green => 1, blue => 2);
for RGBCOLORS'Size use 32;

RGBCOLORS_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
RGBCOLORS_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 2;
RGBCOLORS_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
RGBCOLORS_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 2;
RGBCOLORS_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION RGBCOLORS_Init return RGBCOLORS;
---# derives val from;
FUNCTION RGBCOLORS_IsConstraintValid(val : in RGBCOLORS) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;
FUNCTION RGBCOLORS_Equal(val1, val2: in RGBCOLORS) return Boolean;


SUBTYPE RGBCOLORS_uPER_bit_array_range is Natural range 1..RGBCOLORS_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE RGBCOLORS_uPER_bit_array is adaasn1rtl.BitArray(RGBCOLORS_uPER_bit_array_range);

TYPE RGBCOLORS_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : RGBCOLORS_uPER_bit_array;
END RECORD;
PROCEDURE RGBCOLORS_uPER_Encode(val:in RGBCOLORS; Stream : OUT RGBCOLORS_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE RGBCOLORS_uPER_Decode(val: out RGBCOLORS; Stream : IN RGBCOLORS_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE RGBCOLORS_uPER_Encode_aux(val:in RGBCOLORS; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + RGBCOLORS_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+RGBCOLORS_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE RGBCOLORS_uPER_Decode_aux(val: out RGBCOLORS; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + RGBCOLORS_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+RGBCOLORS_REQUIRED_BITS_FOR_ENCODING;

ERR_RGBCOLORS_unknown_enumeration_value:CONSTANT INTEGER := 1002; -- 
ERR_RGBCOLORS:CONSTANT INTEGER := 1001; -- (((red) | (green)) | (blue))

-----------------------------------------------------------CH1_left-------------------------------------------------------------
SUBTYPE CH1_left IS adaasn1rtl.Asn1Int range 1..10;

CH1_left_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
CH1_left_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 4;
CH1_left_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
CH1_left_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 4;
CH1_left_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION CH1_left_Init return CH1_left;
---# derives val from;
FUNCTION CH1_left_IsConstraintValid(val : in CH1_left) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;
FUNCTION CH1_left_Equal(val1, val2: in CH1_left) return Boolean;


SUBTYPE CH1_left_uPER_bit_array_range is Natural range 1..CH1_left_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE CH1_left_uPER_bit_array is adaasn1rtl.BitArray(CH1_left_uPER_bit_array_range);

TYPE CH1_left_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : CH1_left_uPER_bit_array;
END RECORD;
PROCEDURE CH1_left_uPER_Encode(val:in CH1_left; Stream : OUT CH1_left_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE CH1_left_uPER_Decode(val: out CH1_left; Stream : IN CH1_left_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE CH1_left_uPER_Encode_aux(val:in CH1_left; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + CH1_left_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+CH1_left_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE CH1_left_uPER_Decode_aux(val: out CH1_left; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K  & result from K,S;
--# pre K.K+1>= S'First and K.K + CH1_left_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+CH1_left_REQUIRED_BITS_FOR_ENCODING;

ERR_CH1_left:CONSTANT INTEGER := 1003; -- (1 .. 10)

-----------------------------------------------------------CH1-------------------------------------------------------------
TYPE CH1 IS PRIVATE;
SUBTYPE CH1_index_range is integer range 0..1;

TYPE CH1_selection IS (left_PRESENT, right_PRESENT);
for CH1_selection use
    (left_PRESENT => 1, right_PRESENT => 2);
for CH1_selection'Size use 32;


-- getters and setters
FUNCTION CH1_kind(val:CH1) RETURN CH1_selection;
FUNCTION CH1_left_get(val:CH1) RETURN CH1_left;
--# pre CH1_kind(val) = left_PRESENT;
FUNCTION CH1_left_set(itm:CH1_left) RETURN CH1;
FUNCTION CH1_right_get(val:CH1) RETURN RGBCOLORS;
--# pre CH1_kind(val) = right_PRESENT;
FUNCTION CH1_right_set(itm:RGBCOLORS) RETURN CH1;

CH1_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := 1;
CH1_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := 6;
CH1_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := 1;
CH1_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := 6;
CH1_REQUIRED_BYTES_FOR_XER_ENCODING:CONSTANT INTEGER :=  0;

FUNCTION CH1_Init return CH1;
---# derives val from;
FUNCTION CH1_IsConstraintValid(val : in CH1) return adaasn1rtl.ASN1_RESULT;
---# derives result from val;
FUNCTION CH1_Equal(val1, val2: in CH1) return Boolean;

FUNCTION "=" (val1, val2: in CH1) return Boolean renames CH1_Equal;
SUBTYPE CH1_uPER_bit_array_range is Natural range 1..CH1_REQUIRED_BITS_FOR_ENCODING;
SUBTYPE CH1_uPER_bit_array is adaasn1rtl.BitArray(CH1_uPER_bit_array_range);

TYPE CH1_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : CH1_uPER_bit_array;
END RECORD;
PROCEDURE CH1_uPER_Encode(val:in CH1; Stream : OUT CH1_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives Stream from val & result from val ;
PROCEDURE CH1_uPER_Decode(val: out CH1; Stream : IN CH1_uPER_Stream; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE CH1_uPER_Encode_aux(val:in CH1; S : in out adaasn1rtl.BitArray; K : in out Natural; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives S from S , K, val & K from K, val & result from val ;
--# pre K+1>= S'First and K + CH1_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K>=K~ and K<=K~+CH1_REQUIRED_BITS_FOR_ENCODING;
PROCEDURE CH1_uPER_Decode_aux(val: out CH1; S : in adaasn1rtl.BitArray; K : in out adaasn1rtl.DECODE_PARAMS; result : OUT adaasn1rtl.ASN1_RESULT);
--# derives val from S , K &
--#         K from K ,S & result from K,S;
--# pre K.K+1>= S'First and K.K + CH1_REQUIRED_BITS_FOR_ENCODING <= S'Last;
--# post K.K>=K~.K and K.K<=K~.K+CH1_REQUIRED_BITS_FOR_ENCODING;

ERR_CH1_unknown_choice_index:CONSTANT INTEGER := 1004; -- 


 

private
   --# hide MOD1;

   TYPE CH1(kind : CH1_selection:= left_PRESENT) IS 
   RECORD
       case kind is
       when left_PRESENT =>
               left: CH1_left;
       when right_PRESENT =>
               right: RGBCOLORS;
       end case;
   END RECORD;
   
   FOR CH1 USE 
   RECORD
       kind AT 0 RANGE 0..31;
   END RECORD;

END MOD1;