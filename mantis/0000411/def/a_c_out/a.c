/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "a.h"


#ifndef _MSC_VER
void RGBCOLORS_Initialize(RGBCOLORS* pVal)
{
    static RGBCOLORS ret = 
        red;
    *pVal = ret;
}
#endif

 
flag RGBCOLORS_IsConstraintValid(const RGBCOLORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == red) || (*pVal == green)) || (*pVal == blue));
	*pErrCode = ret ? 0 : ERR_RGBCOLORS;

	return ret;
}

flag RGBCOLORS_Equal(const RGBCOLORS* pVal1, const RGBCOLORS* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag RGBCOLORS_Encode(const RGBCOLORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? RGBCOLORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case red:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case green:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case blue:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = 1073741825; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag RGBCOLORS_Decode(RGBCOLORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : 268435457;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = red;
	            break;
	        case 1: 
	            *pVal = green;
	            break;
	        case 2: 
	            *pVal = blue;
	            break;
	        default:
		        *pErrCode = 1073741826;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void CH1_left_Initialize(CH1_left* pVal)
{
    static CH1_left ret = 
        1;
    *pVal = ret;
}
#endif

 
flag CH1_left_IsConstraintValid(const CH1_left* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= *pVal && *pVal <= 10);
	*pErrCode = ret ? 0 : ERR_CH1_left;

	return ret;
}

flag CH1_left_Equal(const CH1_left* pVal1, const CH1_left* pVal2)
{
	flag ret=TRUE;
	
	ret = (*pVal1 == *pVal2);

	return ret;
}

flag CH1_left_Encode(const CH1_left* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH1_left_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 1, 10);
    }

	return ret;
}

flag CH1_left_Decode(CH1_left* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 1, 10);
	*pErrCode = ret ? 0 : 268435458;

	return ret;
}
#ifndef _MSC_VER
void CH1_Initialize(CH1* pVal)
{
    static CH1 ret = 
        {
            .kind = left_PRESENT,
            .u = { .left = 1}
        };
    *pVal = ret;
}
#endif

 
flag CH1_IsConstraintValid(const CH1* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case left_PRESENT :
	        ret = CH1_left_IsConstraintValid(&pVal->u.left, pErrCode);
	        break;
	    case right_PRESENT :
	        ret = RGBCOLORS_IsConstraintValid(&pVal->u.right, pErrCode);
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag CH1_Equal(const CH1* pVal1, const CH1* pVal2)
{
	flag ret=TRUE;
	
	ret = (pVal1->kind == pVal2->kind);
	if (ret) {
		switch(pVal1->kind) 
		{
		case left_PRESENT:
			ret = CH1_left_Equal(&pVal1->u.left, &pVal2->u.left);
			break;
		case right_PRESENT:
			ret = RGBCOLORS_Equal(&pVal1->u.right, &pVal2->u.right);
			break;
		default:
			ret = FALSE;    //COVERAGE_IGNORE
		}
	}

	return ret;
}

flag CH1_Encode(const CH1* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? CH1_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case left_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = CH1_left_Encode(&pVal->u.left, pBitStrm, pErrCode, FALSE);
	    	break;
	    case right_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = RGBCOLORS_Encode(&pVal->u.right, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = 805306370;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag CH1_Decode(CH1* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : 268435459;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = left_PRESENT;
	    	ret = CH1_left_Decode(&pVal->u.left, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = right_PRESENT;
	    	ret = RGBCOLORS_Decode(&pVal->u.right, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = 805306371;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

