/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "a.h"


#ifndef _MSC_VER
void C_Initialize(C* pVal)
{
    static C ret = 
        0;
    *pVal = ret;
}
#endif

 
flag C_IsConstraintValid(const C* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 100);
	*pErrCode = ret ? 0 : ERR_C;

	return ret;
}

flag C_Encode(const C* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? C_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 100);
    }

	return ret;
}

flag C_Decode(C* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 100);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;

	return ret;
}
#ifndef _MSC_VER
void COLOR_TYPE_Initialize(COLOR_TYPE* pVal)
{
    static COLOR_TYPE ret = 
        0;
    *pVal = ret;
}
#endif

 
flag COLOR_TYPE_IsConstraintValid(const COLOR_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_COLOR_TYPE;

	return ret;
}

flag COLOR_TYPE_Encode(const COLOR_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? COLOR_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 255);
    }

	return ret;
}

flag COLOR_TYPE_Decode(COLOR_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;

	return ret;
}
#ifndef _MSC_VER
void COLOR_DATA_Initialize(COLOR_DATA* pVal)
{
    static COLOR_DATA ret = 
        {
            .kind = green_PRESENT,
            .u = { .green = 0}
        };
    *pVal = ret;
}
#endif

 
flag COLOR_DATA_IsConstraintValid(const COLOR_DATA* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case green_PRESENT :
	        ret = COLOR_TYPE_IsConstraintValid(&pVal->u.green, pErrCode);
	        break;
	    case red_PRESENT :
	        ret = COLOR_TYPE_IsConstraintValid(&pVal->u.red, pErrCode);
	        break;
	    default:
		    *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

flag COLOR_DATA_Encode(const COLOR_DATA* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? COLOR_DATA_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case green_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	    	ret = COLOR_TYPE_Encode(&pVal->u.green, pBitStrm, pErrCode, FALSE);
	    	break;
	    case red_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	    	ret = COLOR_TYPE_Encode(&pVal->u.red, pBitStrm, pErrCode, FALSE);
	    	break;
	    default:
	        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;         //COVERAGE_IGNORE
	        ret = FALSE;                    //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag COLOR_DATA_Decode(COLOR_DATA* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nChoiceIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nChoiceIndex, 0, 1);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	if (ret) {
	    switch(nChoiceIndex) 
	    {
	    case 0:
	    	pVal->kind = green_PRESENT;
	    	ret = COLOR_TYPE_Decode(&pVal->u.green, pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = red_PRESENT;
	    	ret = COLOR_TYPE_Decode(&pVal->u.red, pBitStrm, pErrCode);
	    	break;
	    default:
	        *pErrCode = ERR_INVALID_CHOICE_ALTERNATIVE;     //COVERAGE_IGNORE
	        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void T_enum_Initialize(T_enum* pVal)
{
    static T_enum ret = 
        T_enum_pink;
    *pVal = ret;
}
#endif

 
flag T_enum_IsConstraintValid(const T_enum* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}

flag T_enum_Encode(const T_enum* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? T_enum_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case T_enum_pink:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case T_enum_yellow:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case T_enum_brown:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_ENUM_VALUE; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag T_enum_Decode(T_enum* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = T_enum_pink;
	            break;
	        case 1: 
	            *pVal = T_enum_yellow;
	            break;
	        case 2: 
	            *pVal = T_enum_brown;
	            break;
	        default:
		        *pErrCode = ERR_INVALID_ENUM_VALUE;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void A_elm_Initialize(A_elm* pVal)
{
    static A_elm ret = 
        0;
    *pVal = ret;
}
#endif

 
flag A_elm_IsConstraintValid(const A_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 5);
	*pErrCode = ret ? 0 : ERR_A_elm;

	return ret;
}

flag A_elm_Encode(const A_elm* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? A_elm_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 0, 5);
    }

	return ret;
}

flag A_elm_Decode(A_elm* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 0, 5);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;

	return ret;
}
#ifndef _MSC_VER
void A_Initialize(A* pVal)
{
    static A ret = 
        {    .nCount = 1,    .arr = 
            {
                0        
            }
        };
    *pVal = ret;
}
#endif

 
flag A_IsConstraintValid(const A* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;
	int i1=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 10);
	*pErrCode = ret ? 0 : ERR_A;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = A_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag A_Encode(const A* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? A_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 10);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = A_elm_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag A_Decode(A* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 10);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = A_elm_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#ifndef _MSC_VER
void B_1_Initialize(B_1* pVal)
{
    static B_1 ret = 
        {    .nCount = 2,    .arr = 
            {
                0,
                0        
            }
        };
    *pVal = ret;
}
#endif

 
flag B_1_IsConstraintValid(const B_1* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;
	int i1=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 10) && (2 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_B_1;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = A_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}

flag B_1_Encode(const B_1* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1=0;
    
	ret = bCheckConstraints ? B_1_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 2, 3);
	    	
	    for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	    {
	    	ret = A_elm_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
	    }
    }

	return ret;
}

flag B_1_Decode(B_1* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint nCount;
	int i1=0;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 2, 3);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < pVal->nCount) && ret; i1++) 
	{
		ret = A_elm_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
	}

	return ret;
}
#ifndef _MSC_VER
void B_Initialize(B* pVal)
{
    static B ret = 
        {    .nCount = 2,    .arr = 
            {
                0,
                0        
            }
        };
    *pVal = ret;
}
#endif

 
flag B_IsConstraintValid(const B* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = B_1_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag B_Encode(const B* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? B_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = B_1_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag B_Decode(B* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = B_1_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}
#ifndef _MSC_VER
void MySeq_myEnum_4_Initialize(MySeq_myEnum_4* pVal)
{
    static MySeq_myEnum_4 ret = 
        MySeq_myEnum_4_pink;
    *pVal = ret;
}
#endif

 
flag MySeq_myEnum_4_IsConstraintValid(const MySeq_myEnum_4* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == MySeq_myEnum_4_yellow) || (*pVal == MySeq_myEnum_4_brown));
	*pErrCode = ret ? 0 : ERR_MySeq_myEnum_4;

	return ret;
}

flag MySeq_myEnum_4_Encode(const MySeq_myEnum_4* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_myEnum_4_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case MySeq_myEnum_4_pink:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case MySeq_myEnum_4_yellow:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case MySeq_myEnum_4_brown:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:
	    	    *pErrCode = ERR_INVALID_ENUM_VALUE; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag MySeq_myEnum_4_Decode(MySeq_myEnum_4* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = MySeq_myEnum_4_pink;
	            break;
	        case 1: 
	            *pVal = MySeq_myEnum_4_yellow;
	            break;
	        case 2: 
	            *pVal = MySeq_myEnum_4_brown;
	            break;
	        default:
		        *pErrCode = ERR_INVALID_ENUM_VALUE;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}
#ifndef _MSC_VER
void MySeq_Initialize(MySeq* pVal)
{
    static MySeq ret = 
        {
            .myEnum = MySeq_myEnum_4_pink,
            .colorData = {
                .kind = green_PRESENT,
                .u = { .green = 0}
            }
        };
    *pVal = ret;
}
#endif

 
flag MySeq_IsConstraintValid(const MySeq* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = MySeq_myEnum_4_IsConstraintValid(&pVal->myEnum, pErrCode);
	if (ret) {
	    ret = COLOR_DATA_IsConstraintValid(&pVal->colorData, pErrCode);
	
	}

	return ret;
}

flag MySeq_Encode(const MySeq* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? MySeq_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode myEnum */
	    ret = MySeq_myEnum_4_Encode(&pVal->myEnum, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode colorData */
	        ret = COLOR_DATA_Encode(&pVal->colorData, pBitStrm, pErrCode, FALSE);
	    
	    }
    }

	return ret;
}

flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode myEnum */
	ret = MySeq_myEnum_4_Decode(&pVal->myEnum, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode colorData */
	    ret = COLOR_DATA_Decode(&pVal->colorData, pBitStrm, pErrCode);
	
	}


	return ret;
}
#ifndef _MSC_VER
void E_3_Initialize(E_3* pVal)
{
    static E_3 ret = 
        10;
    *pVal = ret;
}
#endif

 
flag E_3_IsConstraintValid(const E_3* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 100) && (*pVal == 10);
	*pErrCode = ret ? 0 : ERR_E_3;

	return ret;
}

flag E_3_Encode(const E_3* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? E_3_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /* No need to encode value since it will always be 10 */
    }

	return ret;
}

flag E_3_Decode(E_3* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	*pVal=10; ret = TRUE; *pErrCode = 0;

	return ret;
}
#ifndef _MSC_VER
void E_Initialize(E* pVal)
{
    static E ret = 
        10;
    *pVal = ret;
}
#endif

 
flag E_IsConstraintValid(const E* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = E_3_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag E_Encode(const E* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? E_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = E_3_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag E_Decode(E* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = E_3_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}
#ifndef _MSC_VER
void D_2_Initialize(D_2* pVal)
{
    static D_2 ret = 
        90;
    *pVal = ret;
}
#endif

 
flag D_2_IsConstraintValid(const D_2* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 100) && (90 <= *pVal && *pVal <= 100);
	*pErrCode = ret ? 0 : ERR_D_2;

	return ret;
}

flag D_2_Encode(const D_2* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? D_2_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, *pVal, 90, 100);
    }

	return ret;
}

flag D_2_Decode(D_2* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, 90, 100);
	*pErrCode = ret ? 0 : ERR_INSUFFICIENT_DATA;

	return ret;
}
#ifndef _MSC_VER
void D_Initialize(D* pVal)
{
    static D ret = 
        90;
    *pVal = ret;
}
#endif

 
flag D_IsConstraintValid(const D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = D_2_IsConstraintValid(pVal, pErrCode);

	return ret;
}

flag D_Encode(const D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = D_2_Encode(pVal, pBitStrm, pErrCode, FALSE);
    }

	return ret;
}

flag D_Decode(D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = D_2_Decode(pVal, pBitStrm, pErrCode);

	return ret;
}

