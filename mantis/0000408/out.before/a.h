#ifndef _INC_A_H
#define _INC_A_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif



typedef asn1SccSint C;

#define C_REQUIRED_BYTES_FOR_ENCODING       1 
#define C_REQUIRED_BITS_FOR_ENCODING        7
#define C_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define C_REQUIRED_BITS_FOR_ACN_ENCODING    7
#define C_REQUIRED_BYTES_FOR_XER_ENCODING   27

void C_Initialize(C* pVal);
flag C_IsConstraintValid(const C* val, int* pErrCode);
#ifndef ERR_C 
#define ERR_C		1001  /*(0 .. 100)*/
#endif

typedef asn1SccSint COLOR_TYPE;

#define COLOR_TYPE_REQUIRED_BYTES_FOR_ENCODING       1 
#define COLOR_TYPE_REQUIRED_BITS_FOR_ENCODING        8
#define COLOR_TYPE_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define COLOR_TYPE_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define COLOR_TYPE_REQUIRED_BYTES_FOR_XER_ENCODING   45

void COLOR_TYPE_Initialize(COLOR_TYPE* pVal);
flag COLOR_TYPE_IsConstraintValid(const COLOR_TYPE* val, int* pErrCode);
#ifndef ERR_COLOR_TYPE 
#define ERR_COLOR_TYPE		1002  /*(0 .. 255)*/
#endif

typedef struct {
    enum {
        COLOR_DATA_NONE,
        green_PRESENT,
        red_PRESENT 
    } kind;
    union {
        COLOR_TYPE green;
        COLOR_TYPE red;
    } u; 
} COLOR_DATA;

#define COLOR_DATA_REQUIRED_BYTES_FOR_ENCODING       2 
#define COLOR_DATA_REQUIRED_BITS_FOR_ENCODING        10
#define COLOR_DATA_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define COLOR_DATA_REQUIRED_BITS_FOR_ACN_ENCODING    10
#define COLOR_DATA_REQUIRED_BYTES_FOR_XER_ENCODING   60

void COLOR_DATA_Initialize(COLOR_DATA* pVal);
flag COLOR_DATA_IsConstraintValid(const COLOR_DATA* val, int* pErrCode);
#ifndef ERR_COLOR_DATA_unknown_choice_index 
#define ERR_COLOR_DATA_unknown_choice_index		1003  /**/
#endif

typedef enum {
    T_enum_pink = 0,
    T_enum_yellow = 1,
    T_enum_brown = 2
} T_enum;

#define T_enum_REQUIRED_BYTES_FOR_ENCODING       1 
#define T_enum_REQUIRED_BITS_FOR_ENCODING        2
#define T_enum_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define T_enum_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define T_enum_REQUIRED_BYTES_FOR_XER_ENCODING   32

void T_enum_Initialize(T_enum* pVal);
flag T_enum_IsConstraintValid(const T_enum* val, int* pErrCode);
#ifndef ERR_T_enum_unknown_enumeration_value 
#define ERR_T_enum_unknown_enumeration_value		1004  /**/
#endif

typedef asn1SccSint A_elm;

#define A_elm_REQUIRED_BYTES_FOR_ENCODING       1 
#define A_elm_REQUIRED_BITS_FOR_ENCODING        3
#define A_elm_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define A_elm_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define A_elm_REQUIRED_BYTES_FOR_XER_ENCODING   35

void A_elm_Initialize(A_elm* pVal);
flag A_elm_IsConstraintValid(const A_elm* val, int* pErrCode);
#ifndef ERR_A_elm 
#define ERR_A_elm		1005  /*(0 .. 5)*/
#endif

typedef struct {    int nCount; 
    
    A_elm arr[10];
} A;

#define A_REQUIRED_BYTES_FOR_ENCODING       5 
#define A_REQUIRED_BITS_FOR_ENCODING        34
#define A_REQUIRED_BYTES_FOR_ACN_ENCODING   5 
#define A_REQUIRED_BITS_FOR_ACN_ENCODING    34
#define A_REQUIRED_BYTES_FOR_XER_ENCODING   397

void A_Initialize(A* pVal);
flag A_IsConstraintValid(const A* val, int* pErrCode);
#ifndef ERR_A 
#define ERR_A		1006  /*(SIZE(1 .. 10))*/
#endif

typedef struct {    int nCount; 
    
    A_elm arr[3];
} B_1;

#define B_1_REQUIRED_BYTES_FOR_ENCODING       2 
#define B_1_REQUIRED_BITS_FOR_ENCODING        10
#define B_1_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define B_1_REQUIRED_BITS_FOR_ACN_ENCODING    10
#define B_1_REQUIRED_BYTES_FOR_XER_ENCODING   128

void B_1_Initialize(B_1* pVal);
flag B_1_IsConstraintValid(const B_1* val, int* pErrCode);
#ifndef ERR_B_1 
#define ERR_B_1		1007  /*(SIZE(1 .. 10))(SIZE(2 .. 3))*/
#endif

typedef B_1 B;

#define B_REQUIRED_BYTES_FOR_ENCODING       2 
#define B_REQUIRED_BITS_FOR_ENCODING        10
#define B_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define B_REQUIRED_BITS_FOR_ACN_ENCODING    10
#define B_REQUIRED_BYTES_FOR_XER_ENCODING   124

void B_Initialize(B* pVal);
flag B_IsConstraintValid(const B* val, int* pErrCode);


typedef enum {
    MySeq_myEnum_4_pink = 0,
    MySeq_myEnum_4_yellow = 1,
    MySeq_myEnum_4_brown = 2
} MySeq_myEnum_4;

#define MySeq_myEnum_4_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySeq_myEnum_4_REQUIRED_BITS_FOR_ENCODING        2
#define MySeq_myEnum_4_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySeq_myEnum_4_REQUIRED_BITS_FOR_ACN_ENCODING    2
#define MySeq_myEnum_4_REQUIRED_BYTES_FOR_XER_ENCODING   48

void MySeq_myEnum_4_Initialize(MySeq_myEnum_4* pVal);
flag MySeq_myEnum_4_IsConstraintValid(const MySeq_myEnum_4* val, int* pErrCode);
#ifndef ERR_MySeq_myEnum_4_unknown_enumeration_value 
#define ERR_MySeq_myEnum_4_unknown_enumeration_value		1009  /**/
#endif
#ifndef ERR_MySeq_myEnum_4 
#define ERR_MySeq_myEnum_4		1008  /*((yellow) | (brown))*/
#endif

typedef struct {
    MySeq_myEnum_4 myEnum;
    COLOR_DATA colorData;
} MySeq;

#define MySeq_REQUIRED_BYTES_FOR_ENCODING       2 
#define MySeq_REQUIRED_BITS_FOR_ENCODING        12
#define MySeq_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define MySeq_REQUIRED_BITS_FOR_ACN_ENCODING    12
#define MySeq_REQUIRED_BYTES_FOR_XER_ENCODING   105

void MySeq_Initialize(MySeq* pVal);
flag MySeq_IsConstraintValid(const MySeq* val, int* pErrCode);


typedef asn1SccSint E_3;

#define E_3_REQUIRED_BYTES_FOR_ENCODING       0 
#define E_3_REQUIRED_BITS_FOR_ENCODING        0
#define E_3_REQUIRED_BYTES_FOR_ACN_ENCODING   0 
#define E_3_REQUIRED_BITS_FOR_ACN_ENCODING    0
#define E_3_REQUIRED_BYTES_FOR_XER_ENCODING   31

void E_3_Initialize(E_3* pVal);
flag E_3_IsConstraintValid(const E_3* val, int* pErrCode);
#ifndef ERR_E_3 
#define ERR_E_3		1010  /*(0 .. 100)(10)*/
#endif

typedef E_3 E;

#define E_REQUIRED_BYTES_FOR_ENCODING       0 
#define E_REQUIRED_BITS_FOR_ENCODING        0
#define E_REQUIRED_BYTES_FOR_ACN_ENCODING   0 
#define E_REQUIRED_BITS_FOR_ACN_ENCODING    0
#define E_REQUIRED_BYTES_FOR_XER_ENCODING   27

void E_Initialize(E* pVal);
flag E_IsConstraintValid(const E* val, int* pErrCode);


typedef asn1SccSint D_2;

#define D_2_REQUIRED_BYTES_FOR_ENCODING       1 
#define D_2_REQUIRED_BITS_FOR_ENCODING        4
#define D_2_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define D_2_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define D_2_REQUIRED_BYTES_FOR_XER_ENCODING   31

void D_2_Initialize(D_2* pVal);
flag D_2_IsConstraintValid(const D_2* val, int* pErrCode);
#ifndef ERR_D_2 
#define ERR_D_2		1011  /*(0 .. 100)(90 .. 100)*/
#endif

typedef D_2 D;

#define D_REQUIRED_BYTES_FOR_ENCODING       1 
#define D_REQUIRED_BITS_FOR_ENCODING        4
#define D_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define D_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define D_REQUIRED_BYTES_FOR_XER_ENCODING   27

void D_Initialize(D* pVal);
flag D_IsConstraintValid(const D* val, int* pErrCode);


 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

flag C_Encode(const C* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag C_Decode(C* pVal, BitStream* pBitStrm, int* pErrCode);
flag COLOR_TYPE_Encode(const COLOR_TYPE* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag COLOR_TYPE_Decode(COLOR_TYPE* pVal, BitStream* pBitStrm, int* pErrCode);
flag COLOR_DATA_Encode(const COLOR_DATA* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag COLOR_DATA_Decode(COLOR_DATA* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_enum_Encode(const T_enum* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_enum_Decode(T_enum* pVal, BitStream* pBitStrm, int* pErrCode);
flag A_elm_Encode(const A_elm* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag A_elm_Decode(A_elm* pVal, BitStream* pBitStrm, int* pErrCode);
flag A_Encode(const A* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag A_Decode(A* pVal, BitStream* pBitStrm, int* pErrCode);
flag B_1_Encode(const B_1* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag B_1_Decode(B_1* pVal, BitStream* pBitStrm, int* pErrCode);
flag B_Encode(const B* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag B_Decode(B* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_myEnum_4_Encode(const MySeq_myEnum_4* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_myEnum_4_Decode(MySeq_myEnum_4* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_Encode(const MySeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag E_3_Encode(const E_3* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag E_3_Decode(E_3* pVal, BitStream* pBitStrm, int* pErrCode);
flag E_Encode(const E* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag E_Decode(E* pVal, BitStream* pBitStrm, int* pErrCode);
flag D_2_Encode(const D_2* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag D_2_Decode(D_2* pVal, BitStream* pBitStrm, int* pErrCode);
flag D_Encode(const D* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag D_Decode(D* pVal, BitStream* pBitStrm, int* pErrCode); 


#ifdef  __cplusplus
}
#define ENUM_T_enum_pink	T_enum_pink
#define ENUM_T_enum_yellow	T_enum_yellow
#define ENUM_T_enum_brown	T_enum_brown
#define ENUM_MySeq_myEnum_4_pink	MySeq_myEnum_4_pink
#define ENUM_MySeq_myEnum_4_yellow	MySeq_myEnum_4_yellow
#define ENUM_MySeq_myEnum_4_brown	MySeq_myEnum_4_brown
#define CHOICE_green_PRESENT	COLOR_DATA::green_PRESENT
#define CHOICE_red_PRESENT	COLOR_DATA::red_PRESENT

#endif

#endif
