group c_header;

PrintHeaderFile(sFileNameWithNoExtUpperCase, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrototypes, arrsUtilityDefines) ::= <<
#ifndef GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
#define GENERATED_ASN1SCC_<sFileNameWithNoExtUpperCase>_H
/*
Code automatically generated by asn1scc tool
*/
<arrsIncludedModules:{inc| #include "<inc>.h"}; separator="\n">
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

<arrsPrototypes:{proto|<proto>}; separator="\n"> 


#ifdef  __cplusplus
}
<arrsUtilityDefines; separator="\n">

#endif

#endif
>>

/*
C TYPES 
*/


Define_Type(sTypeDefinitionBody, sTypeDefinitionName, noArrLength, arrsChildldrenDefintions) ::= <<
<arrsChildldrenDefintions; separator= "\n">

typedef <sTypeDefinitionBody> <sTypeDefinitionName><if(noArrLength)>[<noArrLength>]<endif>;
>>


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
typedef <sParentType> <sTypeDefinitionName>;
<soExtraDefs>
>>


Declare_Integer() ::="asn1SccSint"
Declare_PosInteger() ::="asn1SccUint"

Declare_Boolean() ::= "flag"

Declare_Real() ::= "double"

Declare_IA5String() ::= "char"
Declare_NumericString() ::= "char"

Declare_NullType() ::= "NullType"



Declare_BitString(bIsFixeSize, nMaxOctets, nMaxBits) ::= <<
struct {
<if(!bIsFixeSize)>
    int nCount; /*Number of bits in the array. Max value is : <nMaxBits> */

<endif>    
    byte arr[<nMaxOctets>];
}
>>

Declare_OctetString(bIsFixeSize, nMaxOctets) ::= <<
struct {
<if(!bIsFixeSize)>
    int nCount; 

<endif>    
    byte arr[<nMaxOctets>];
}
>>

PrintNamedItem(sName, nValue) ::= "<sName> = <nValue>"

Declare_Enumerated(arrsItems) ::= <<
enum {
    <arrsItems:{it|<it>}; separator=",\n">
}
>>


PrintSeq_ChoiceChild(sTypeDecl, sName, sArrayPostfix) ::= "<sTypeDecl> <sName><sArrayPostfix>;"

Declare_Choice(sChoiceIDForNone, arrsEnmItems, arrsChildren) ::= <<
struct {
    enum {
        <sChoiceIDForNone>,
        <arrsEnmItems:{ch|<ch>}; separator=",\n"> 
    } kind;
    union {
        <arrsChildren:{ch|<ch>}; separator="\n">
    } u; 
}
>>

Declare_Sequence(arrsChildren, arrsOptionalChildren) ::= <<
struct {
    <arrsChildren:{ch|<ch>}; separator="\n">
    <if (arrsOptionalChildren)>
    struct {
        <arrsOptionalChildren:{ch|unsigned int <ch>:1;}; separator="\n">
    } exist;
    <endif>
}
>>



Declare_SequenceOf(bIsFixedSize, sTypeDecl, nLength, sArrayPostfix) ::= <<
struct {<if(!bIsFixedSize)>
    int nCount; 

<endif>    
    <sTypeDecl> arr[<nLength>]<sArrayPostfix>;
}
>>



Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>


PrintValueAssignment(sTypeDecl, sName) ::= "extern const <sTypeDecl> <sName>;"
