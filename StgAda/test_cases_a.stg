/*
* Copyright (c) 2008-2012 Semantix and (c) 2012-2015 Neuropublic
*
* This file is part of the ASN1SCC tool.
*
* Licensed under the terms of GNU General Public Licence as published by
* the Free Software Foundation.
*
*  For more informations see License.txt file
*/

group spark_automatic_test_cases;

rtlModuleName() ::= "adaasn1rtl"


PrintCodecsFile_spec(sModName, arrsIncludedModules, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
with adaasn1rtl;
with <sModName>;

<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
<if(arrsIncludedModules)>
--# inherit <arrsIncludedModules; separator=",">;

<endif>
PACKAGE <sModName>_auto_tcs
IS

<arrsTestFunctions; separator="\n\n">

END <sModName>_auto_tcs;
>>
                
PrintCodec_spec(sFuncName, sModName, sTasName, sStar, sVal) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT;
>>


PrintCodecsFile_body(sModName, arrsIncludedModules, arrsTasNames, arrsTestFunctions) ::= <<
-- Code automatically generated by asn1scc tool
with Interfaces;
with adaasn1rtl;
with <sModName>;
use type Interfaces.Unsigned_8;
with <rtlModuleName()>;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| WITH <inc>; USE <inc>;}; separator="\n">
<arrsTasNames: {tasName|use type <tasName>;}; separator="\n">
PACKAGE BODY <sModName>_auto_tcs 
IS 

<arrsTestFunctions; separator="\n\n">

END <sModName>_auto_tcs;
>>



Codec_UpdateDecInParam_no_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>);
>>

Codec_UpdateDecInParam_with_result(sModName, sTasName, sParamName) ::= <<
<sModName>.<sTasName>_ACN_Encode_update_<sParamName>(val,  dec_<sParamName>, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>


Codec_validate_input(sModName, sFuncName, sAmber) ::= <<
-- Check value against ASN.1 constraints
result := <sModName>.<sFuncName>(val);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Encode(sModName, sFuncName, sVal) ::= <<
-- Encode value
<sModName>.<sFuncName>(<sVal>, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_ENCODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
-- Decode value
--at this point stream contains the <sEnc> data
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_Decode_XER(sModName, sFuncName, sTasName, sEnc, sAmber) ::= <<
-- Decode value
--at this point stream contains the <sEnc> data
<sModName>.<sFuncName>(decodedPDU, stream, result);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_DECODE, Success => result.Success, ErrorCode => result.ErrorCode);
>>



Codec_validate_output(sModName, sFuncName, sAmber) ::= <<
-- validate decoded data
result := <sModName>.<sFuncName>(decodedPDU);
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_VALIDATE_DECODED, Success => result.Success, ErrorCode => result.ErrorCode);
>>

Codec_compare_input_with_output(sModName, sFuncName, sVal, sAmber) ::= <<
ret := <rtlModuleName()>.TEST_CASE_RESULT'(Step => <rtlModuleName()>.TC_EQUAL, Success => <sModName>.<sFuncName>(<sVal>, decodedPDU), ErrorCode => result.ErrorCode);
>>


JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
IF result.Success THEN
    <soNestedPart>
END IF;

<endif>
>>


Codec_declare_EncInDecOut_variable(sPrmName, sType, sPrmValue) ::= <<
enc_<sPrmName> : CONSTANT <sType> := <sPrmValue>;
dec_<sPrmName> : <sType>;
>>

Codec_declare_DecIn_variable(sPrmName, sType) ::= "dec_<sPrmName> : <sType>;"

        



PrintCodec_body(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT
IS
    decodedPDU  : <sModName>.<sTasName>;
    stream      : <sModName>.<sTasName>_<sEnc>Stream;
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
BEGIN
    <sNestedStatements>
    RETURN ret;
END <sFuncName>;
>>

PrintCodec_body_XER(sModName, sFuncName, sTasName, sStar,  sVal, sEnc, sNestedStatements) ::= <<
FUNCTION <sFuncName>(<sVal>:<sModName>.<sTasName>) RETURN <rtlModuleName()>.TEST_CASE_RESULT
IS
    decodedPDU  : <sModName>.<sTasName>;
    stream      : <sModName>.<sTasName>_<sEnc>Stream;
    result      : <rtlModuleName()>.ASN1_RESULT;
    ret         : <rtlModuleName()>.TEST_CASE_RESULT;
BEGIN
    <sNestedStatements>
    RETURN ret;
END <sFuncName>;
>>


/*
//////////////////////////// CALL TEST CASES ////////////////////////////////////////////////////////////////////
*/



/* 
Code calling a test case
*/                   
PrintMain_call_codec(sModName, sTasName, sAmber, sEnc, sValue, sValueAsAsn1, sVasName, bStatic, sGenerateDatFile, soInitFunction, sInitAmber) ::= <<
result := <sModName>_auto_tcs.<sTasName>_<sEnc>enc_dec(<sValue>);
IF NOT result.Success THEN
    CASE result.Step IS
        WHEN <rtlModuleName()>.TC_VALIDATE =>
            Put_Line ("Test case '<sVasName>' failed in validation"); 
        WHEN <rtlModuleName()>.TC_ENCODE =>
            Put_Line ("Test case '<sVasName>' failed in encoding");
        WHEN <rtlModuleName()>.TC_DECODE =>
            Put_Line ("Test case '<sVasName>' failed in decoding");
        WHEN <rtlModuleName()>.TC_VALIDATE_DECODED =>
            Put_Line ("Test case '<sVasName>' failed in the validation of the decoded message");
        WHEN <rtlModuleName()>.TC_EQUAL =>
            Put_Line ("Test case '<sVasName>' failed. Encoded and decoded messages are different");
    END CASE;
    Put_Line ("Test Value was <sValueAsAsn1>");
    Put_Line ("========================================");
    totalErrors := totalErrors + 1;
END IF;
<sGenerateDatFile>

>>


PrintMain_call_codec2(sModName, sTasName, sAmber, sEnc, sInitializeTcData, sValueAsAsn1, sVasName, bStatic, sGenerateDatFile, soInitFunction, sInitAmber) ::= <<
declare
    tc_data : <sModName>.<sTasName>;
begin
    <if(soInitFunction)>
    -- dummy statement used for calling init functions
    tc_data := <soInitFunction>;
    <endif>
    --the actual initialization with the test case data is made here.
    <sInitializeTcData>
    result := <sModName>_auto_tcs.<sTasName>_<sEnc>enc_dec(tc_data);
    IF NOT result.Success THEN
        CASE result.Step IS
            WHEN <rtlModuleName()>.TC_VALIDATE =>
                Put_Line ("Test case '<sVasName>' failed in validation"); 
            WHEN <rtlModuleName()>.TC_ENCODE =>
                Put_Line ("Test case '<sVasName>' failed in encoding");
            WHEN <rtlModuleName()>.TC_DECODE =>
                Put_Line ("Test case '<sVasName>' failed in decoding");
            WHEN <rtlModuleName()>.TC_VALIDATE_DECODED =>
                Put_Line ("Test case '<sVasName>' failed in the validation of the decoded message");
            WHEN <rtlModuleName()>.TC_EQUAL =>
                Put_Line ("Test case '<sVasName>' failed. Encoded and decoded messages are different");
        END CASE;
        Put_Line ("Test Value was <sValueAsAsn1>");
        Put_Line ("========================================");
        totalErrors := totalErrors + 1;
    END IF;
    <sGenerateDatFile>
end;
>>



PrintMain_call_codec_generate_dat_file(sModName, sTasName, sAmber, sEnc, sStreamName) ::= <<
IF result.Success THEN
    DECLARE
    	stream   : <sModName>.<sTasName>_uPER_Stream;
        ret      : <rtlModuleName()>.ASN1_RESULT;
    BEGIN
        <sModName>.<sTasName>_uPER_Encode(<sValue>, stream, ret);
	    WRITE_STR_TO_FILE(Strm => stream.Data,DataLen => stream.DataLen, fileName => "asn1scc_<sEnc>.dat");
    END;
END IF;
>>

                   

PrintMain(arrsIncludedModules, arrsVars, arrsTestFunctions, arrsUsedPackages, arrsInitCalls, bGenerateDatFile) ::= <<
WITH Ada.Text_IO;
<if(bGenerateDatFile)>
with Ada.Sequential_IO;
with Interfaces;
use type Interfaces.Unsigned_8;
<endif>
WITH <rtlModuleName()>; use type <rtlModuleName()>.Asn1UInt; use type <rtlModuleName()>.Asn1Int;use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| with <inc>;}; separator="\n">
<arrsIncludedModules:{inc| use <inc>;}; separator="\n">
--# inherit <rtlModuleName()>, <arrsIncludedModules; separator=", ">;
--# main_program;


FUNCTION MainProgram RETURN INTEGER
IS --# hide MainProgram
    USE Ada.Text_IO;
    <arrsUsedPackages:{p|USE <p>;}; separator="\n">
    result      : <rtlModuleName()>.TEST_CASE_RESULT;
    totalErrors  : INTEGER:=0;
    <arrsVars; separator="\n">
    
<if(bGenerateDatFile)>
    PROCEDURE WRITE_STR_TO_FILE(Strm : <rtlModuleName()>.BitArray; 
			        DataLen	: Natural;
                                fileName:String) IS
      package Seq_IO is new Ada.Sequential_IO(<rtlModuleName()>.Asn1Byte);
      use Seq_IO;

      MASKS : CONSTANT <rtlModuleName()>.OctetBuffer (1 .. 8) := (16#80#, 16#40#, 16#20#, 16#10#, 16#08#, 16#04#, 16#02#, 16#01#);
      curByte:<rtlModuleName()>.Asn1Byte:=0;
      bitIndex:Integer;
      My_Out_File : Seq_IO.FILE_TYPE;
    BEGIN
      Create(My_Out_File, Out_File, fileName);

      FOR I IN 1..DataLen LOOP
         bitIndex := ((I-1) mod 8) +1;
         IF bitIndex = 1 THEN
            curByte:=0;
         END IF;
         IF Strm(I)=1 THEN
           curByte := curByte OR MASKS(bitIndex);
         END IF;
         IF bitIndex = 8 OR I = DataLen THEN
            Write(My_Out_File, curByte);
         END IF;
      END LOOP;

      Close(My_Out_File);
    END;

<endif>
BEGIN

    <arrsTestFunctions;separator="\n\n">

    -- used to increase statement coverage
    <arrsInitCalls; separator="\n\n">


    IF totalErrors > 0 THEN
        Put_Line (Integer'Image(totalErrors) & " out of <arrsTestFunctions.Length> failed."); 
        RETURN 1;
    ELSE
        Put_Line ("All test cases (<arrsTestFunctions.Length>) run successfully."); 
        RETURN 0;
    END IF;
END MainProgram;
>>

