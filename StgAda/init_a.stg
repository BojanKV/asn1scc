group a_init;



initInteger(p, nValue) ::= "<p> := <nValue>;"
initReal(p, dValue) ::= "<p> := <dValue>;"
initBoolean(p, bValue) ::= "<p> := <if(bValue)>TRUE<else>FALSE<endif>;"

initIA5String(sPtr, sValue) ::= "strcpy(<sPtr>,\"<sValue>\");"
initEnumerated(sVal, sValue) ::= "<sVal> := <sValue>;"
initNull(sVal)    ::= "<sVal> =NULL;"


/* BIT AND OCTET STRINGS */
initFixSizeBitOrOctString_bytei(p, sAcc, sI, sByteHexVal) ::= "<p><sAcc>arr[<sI>] := 0x<sByteHexVal>;"
initFixSizeBitOrOctString(p, sAcc,arrsBytes) ::= <<
<arrsBytes>
>>
initFixVarSizeBitOrOctString(p, sAcc, nSize, arrsBytes) ::= <<
<p><sAcc><nCount> = <nSize>;
<arrsBytes>
>>


/*SEQUENCE OF */


initFixedSequenceOf(arrsInnerValues) ::= <<
<arrsInnerValues; separator=",\n">        
>>


initVarSizeSequenceOf(p, sAcc, nSize, arrsInnerValues) ::= <<
<p><sAcc>Length := <nSize>;
<arrsInnerValues; separator=",\n">        
>>

/*SEQUENCE*/

initSequence_optionalChild(p, sAcc, sChName, sPresentFlag, sChildContent) ::=<<
<p><sAcc>Exist.<sChName> := <sPresentFlag>;
<sChildContent>
>>

initSequence(arrsInnerValues) ::= <<
<arrsInnerValues; separator=",\n">        
>>

initChoice(p1, sAccess, sChildContent, sChildKind) ::= <<
<p1><sAccess>kind := <sChildKind>;
<sChildContent>        
>>


initTypeAssignment_def(sVarName, sStar, sFuncName, sTypeDefName) ::= <<
procedure <sFuncName>(<sVarName>:out <sTypeDefName>);
>>

initTypeAssignment(sVarName, sStar, sFuncName, sTypeDefName, sContent) ::= <<
procedure <sFuncName>(<sVarName>:out <sTypeDefName>)
IS
begin
	<sContent>
end <sFuncName>;
>>

