group a_init;

rtlModuleName() ::= "adaasn1rtl"


initInteger(p, nValue) ::= "<p> := <nValue>;"
initReal(p, dValue) ::= "<p> := <dValue>;"
initBoolean(p, bValue) ::= "<p> := <if(bValue)>TRUE<else>FALSE<endif>;"

PrintStringValue(sValue, arrsNullChars)	::= "\"<sValue>\"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=\" & \"><endif>"
initIA5String(sPtr, sValue, arrsNullChars) ::= "<sPtr> := \"<sValue>\"<if(arrsNullChars)> & <arrsNullChars; wrap, anchor, separator=\" & \"><endif>;" 
initEnumerated(sVal, sValue) ::= "<sVal> := <sValue>;"
initNull(sVal)    ::= "<sVal> := 0;"

initTestCaseIA5String(p, sAcc, nSize, nMaxSizePlusOne, i, sTasName, bAlpha, arrnAlphabetAsciiCodes, nAlphabetLength) ::= <<
<i> := 1;
while <i>\<= <nMaxSizePlusOne> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nMaxSizePlusOne>);
    if <i> \<= <nSize> then
    <if(bAlpha)>
        <p>(<i>) := <sTasName>_alpha_set( ((<i>-1) mod <sTasName>_alpha_set'Last) + 1 );

    <else>
        <p>(<i>) := Character'Val(Integer'Pos( if ((<i>-1) mod 128) = 0 then 65 else (<i>-1) mod 128));

    <endif>
    else
        <p>(<i>) := <rtlModuleName()>.NUL;
    end if;
    <i> := <i> + 1;
end loop;
>>



/* BIT AND OCTET STRINGS */
initFixSizeBitOrOctString_bytei(p, sAcc, sI, sByteHexVal) ::= "<p><sAcc>Data(<sI>) := 16#<sByteHexVal>#;"
initFixSizeBitOrOctString(p, sAcc,arrsBytes) ::= <<
<arrsBytes; separator="\n">
>>
initFixVarSizeBitOrOctString(p, sAcc, nSize, arrsBytes) ::= <<
<p><sAcc>Length := <nSize>;
<arrsBytes; separator="\n">
>>

initTestCaseOctetString(p, sAcc, nSize, i, bIsFixedSize) ::= <<
<i> := 1;
while <i>\<= <nSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nSize>);
    <p><sAcc>Data(<i>) := <rtlModuleName()>.Asn1Byte((<i>-1) mod 256);
    <i> := <i> + 1;
end loop;
<if(!bIsFixedSize)><p><sAcc>Length := <nSize>;<endif>
>>

initTestCaseBitString(p, sAcc, nSize, nSizeCeiled, i, bIsFixedSize) ::= <<
<i> := 1;
while <i>\<= <nSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nSize>);
    <p><sAcc>Data(<i>) := <rtlModuleName()>.BIT((<i>-1) mod 2);
    <i> := <i> + 1;
end loop;
<if(!bIsFixedSize)><p><sAcc>Length := <nSize>;<endif>
>>


/*SEQUENCE OF */

initSequence_pragma(p) ::= <<
pragma Annotate (GNATprove, False_Positive,"""<p>.Data"" might not be initialized", "Data are reserved by caller");
>>

initFixedSequenceOf(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">        
>>


initVarSizeSequenceOf(p, sAcc, nSize, arrsInnerValues) ::= <<
<p><sAcc>Length := <nSize>;
<arrsInnerValues; separator="\n">        
>>

initTestCaseSizeSequenceOf_innerItem(bFirst, bLastItem, nCaseIdx, sChildCaseInit, i, nCaseLen) ::= <<
<if(!bLastItem)><if(bFirst)>if<else>elsif<endif> (<i>-1) mod <nCaseLen> = <nCaseIdx>  then<else>else<endif>
    <sChildCaseInit>
>>

initTestCaseSizeSequenceOf(p, sAcc, nSize, bIsFixedSize, arrsInnerItems, bMultiCases, i) ::= <<
<i> := 1;
while <i>\<= <nSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<nSize>);
    <arrsInnerItems; separator="\n">
    <if(bMultiCases)>       
    end if;

    <endif>
    <i> := <i> + 1;
end loop;
<if(!bIsFixedSize)><p><sAcc>Length := <nSize>;<endif>
>>

/*SEQUENCE*/

initSequence_optionalChild(p, sAcc, sChName, sPresentFlag, sChildContent) ::=<<
<p><sAcc>Exist.<sChName> := <sPresentFlag>;
<sChildContent>
>>

initSequence(arrsInnerValues) ::= <<
<arrsInnerValues; separator="\n">        
>>


initTestCase_sequence_child(p, sAcc, sChName, sChildContent, bOptional) ::= <<
--set <sChName> 
<if(bOptional)><p><sAcc>exist.<sChName> := 1;<endif>
<sChildContent>
>>
initTestCase_sequence_child_opt(p, sAcc, sChName) ::= <<
<p><sAcc>exist.<sChName> := 0;
>>

initTestCase_choice_child(p, sAcc, sChildID, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
--set <sChildName> 
declare
    <sChildName>_tmp:<sChildTypeDef>;
begin
    <sChildContent>
    <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
end;
>>


initChoice(p1, sAccess, sChildContent, sChildKind, sChildTempVarName, sChildTypeName, sChoiceTypeName, sChildName) ::= <<
declare
   <sChildTempVarName> : <sChildTypeName>;
begin
    <sChildContent>        
    <p1> := <sChoiceTypeName>'(kind => <sChildKind>, <sChildName> => <sChildTempVarName>);
    pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
end;
>>


initTypeAssignment_def(sVarName, sStar, sFuncName, sTypeDefName) ::= <<
procedure <sFuncName>(<sVarName>:in out <sTypeDefName>);
>>

initTypeAssignment(sVarName, sStar, sFuncName, sTypeDefName, sContent) ::= <<
procedure <sFuncName>(<sVarName>:in out <sTypeDefName>)
IS
begin
    <sContent>
end <sFuncName>;
>>

