group a_spec;



PrintFile(arrsPackages) ::= <<
<arrsPackages; separator="\n\n">
>>


rtlModuleName() ::= "adaasn1rtl"

PrintPackageSpec(sPackageName, arrsIncludedModules, arrsTypeAssignments, arrsValueAssignments, arrsPrivateChoices) ::= <<
-- Code automatically generated by asn1scc tool
WITH <rtlModuleName()>;
USE <rtlModuleName()>;
use type <rtlModuleName()>.OctetBuffer;
use type <rtlModuleName()>.BitArray;
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;
<arrsIncludedModules:{inc| WITH <inc>; use <inc>;}; separator="\n">
--# inherit <arrsIncludedModules:{inc| <inc>}; separator=",">;


PACKAGE <sPackageName> with SPARK_Mode
IS


<arrsTypeAssignments:{tas|<tas>}; separator="\n">

<arrsValueAssignments:{vas|<vas>}; separator="\n"> 

private
   --# hide <sPackageName>;

   <arrsPrivateChoices; separator="\n">

END <sPackageName>;
>>


PrintNegativeRealConstant(sName, sValue) ::= "<sName>:CONSTANT <rtlModuleName()>.Asn1Real := <sValue>;"

PrintPackageBody(sPackageName, arrsIncludedModules, arrsNegativeReals, arrsBoolPatterns, arrsTypeAssignments, arrsChoiceValueAssignments) ::= <<
-- Code automatically generated by asn1scc tool
<arrsIncludedModules:{inc| WITH <inc>;}; separator="\n">
use type <rtlModuleName()>.Asn1UInt;
use type <rtlModuleName()>.Asn1Int;
use type <rtlModuleName()>.BIT;


PACKAGE BODY <sPackageName> IS

<arrsNegativeReals; separator="\n\n">

<arrsBoolPatterns; separator="\n\n">

<arrsTypeAssignments:{tas|<tas>}; separator="\n\n">

<arrsChoiceValueAssignments:{vas|<vas>}; separator="\n\n"> 

END <sPackageName>;
>>


Define_Type(sTypeOrSubsType, sTypeDefinitionName, sTypeDefinitionBody, arrsChildldrenDefintions) ::= <<
-- <sTypeDefinitionName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">

<sTypeOrSubsType> <sTypeDefinitionName> is <sTypeDefinitionBody>;
>>




Define_TAS(sTypeDefinition, arrsProcs) ::= <<
<sTypeDefinition>

<arrsProcs; separator="\n\n">
>>








PrintValueAssignment(sVasName, sTypeDecl, sValue) ::= <<
<sVasName> : CONSTANT <sTypeDecl>:= <sValue>;
>>

PrintValueAssignment_Choice(sVasName, sTypeDecl, sValue) ::= "FUNCTION <sVasName> RETURN <sTypeDecl>;"

PrintValueAssignment_Choice_body(sVasName, sTypeDecl, sValue) ::= <<
FUNCTION <sVasName> RETURN <sTypeDecl>
IS --# hide <sVasName>;
BEGIN
    RETURN <sValue>;
END <sVasName>;
>>


PrintTypeAssignment(sName, sTasDecl, nMaxBitsInPER, nMaxBytesInPER, nMaxBitsInACN, nMaxBytesInACN, arrsErrorCodes, bGenIsValid, bGenEqual, arrsEncPrototypes, bIsComplex) ::= <<
-----------------------------------------------------------<sName>-------------------------------------------------------------
<sTasDecl>

<sName>_REQUIRED_BYTES_FOR_ENCODING:CONSTANT INTEGER := <nMaxBytesInPER>;
<sName>_REQUIRED_BITS_FOR_ENCODING:CONSTANT INTEGER := <nMaxBitsInPER>;
<sName>_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBytesInACN>;
<sName>_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBitsInACN>;

FUNCTION <sName>_Init return <sName>;
---# derives val from;
<if(bGenIsValid)>
FUNCTION <sName>_IsConstraintValid(val : in <sName>) return <rtlModuleName()>.ASN1_RESULT;
---# derives result from val;

<endif>
<if(bGenEqual)>
FUNCTION <sName>_Equal(val1, val2: in <sName>) return Boolean;

<if(bIsComplex)>
FUNCTION "=" (val1, val2: in <sName>) return Boolean renames <sName>_Equal;
<endif>

<endif>

<arrsEncPrototypes: {pr|<pr>}; separator="\n">

<arrsErrorCodes: {pr|<pr>}; separator="\n">

>>


PRIMITIVE_tas_decl(sName, sTypeDecl) ::= <<
SUBTYPE <sName> IS <sTypeDecl>;
>>

SEQUENCE_tas_decl_child_bit(sName) ::= "<sName>:<rtlModuleName()>.BIT;"

SEQUENCE_tas_decl_child(sName, sType) ::= "<sName> : <sType>;"

SEQUENCE_tas_decl(sName, arrsChildren, arrsOptionalChildren, arrsChildldrenDefintions) ::= <<
-- <sName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">

<if(arrsChildren)>
<if (arrsOptionalChildren)>
TYPE <sName>_EXIST IS RECORD
    <arrsOptionalChildren; separator="\n">
END RECORD;

<endif>
TYPE <sName> IS RECORD 
    <arrsChildren; separator="\n">
    <if (arrsOptionalChildren)>
    
    Exist : <sName>_EXIST;

    <endif>
END RECORD;

<else>
TYPE <sName> IS RECORD 
    null;
END RECORD;

<endif>
>>

Define_SubType_sequence(sTypeDefinitionName, soParentTypePackage, sParentType, arrsOptionalChildren) ::= <<
<if(arrsOptionalChildren)>
SUBTYPE <sTypeDefinitionName>_EXIST is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_EXIST;

<endif>
>>

CHOICE_tas_decl_child(sName, sType, sPresent) ::=<<
when <sPresent> =>
        <sName>: <sType>;
>>

CHOICE_tas_decl(sName, sFirstChildNamePresent, arrsChildren, arrsPresent, nIndexMax, arrsChildldrenDefintions) ::= <<
-- <sName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">

SUBTYPE <sName>_index_range is integer range 0..<nIndexMax>;

TYPE <sName>_selection IS (<arrsPresent; separator=", ">);
for <sName>_selection use
    (<arrsPresent:{c|<c> => <i>}; separator=", ">);
for <sName>_selection'Size use 32;

TYPE <sName>(kind : <sName>_selection:= <sFirstChildNamePresent>) IS 
RECORD
    case kind is
    <arrsChildren; separator="\n">
    end case;
END RECORD;

FOR <sName> USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;
>>

Define_SubType_choice(sTypeDefinitionName, soParentTypePackage, sParentType) ::= <<
SUBTYPE <sTypeDefinitionName>_index_range is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_index_range;
SUBTYPE <sTypeDefinitionName>_selection is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_selection;
>>








SEQUENCE_OF_tas_decl(sName, nMin, nMax, bFixedSize, sChildType, arrsChildldrenDefintions) ::= <<
-- <sName> --------------------------------------------
<arrsChildldrenDefintions; separator= "\n">
SUBTYPE <sName>_index is integer range 1..<nMax>;
TYPE <sName>_array IS ARRAY (<sName>_index) OF <sChildType>;
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>

Define_SubType_sizeable(sTypeDefinitionName, soParentTypePackage, sParentType) ::= <<
SUBTYPE <sTypeDefinitionName>_index is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_index;
SUBTYPE <sTypeDefinitionName>_array is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_array;
>>


BIT_STRING_tas_decl(sName, nMin, nMax, bFixedSize) ::= <<
SUBTYPE <sName>_index is integer range 1..<nMax>;
SUBTYPE <sName>_array IS <rtlModuleName()>.BitArray(<sName>_index);
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>

OCTET_STRING_tas_decl(sName, nMin, nMax, bFixedSize) ::= <<
SUBTYPE <sName>_index is integer range 1..<nMax>;
SUBTYPE <sName>_array IS <rtlModuleName()>.OctetBuffer(<sName>_index);
<if(!bFixedSize)>SUBTYPE <sName>_length_index is integer range <nMin>..<nMax>;<endif>
TYPE <sName> IS  RECORD
<if(!bFixedSize)>    Length : <sName>_length_index;<endif>
    Data  : <sName>_array;
END RECORD;
>>

/* nCMax = nMax + 1*/
IA5STRING_OF_tas_decl(sName, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
SUBTYPE <sName>_encoding_range is integer range <nMin>..<nMax>;
SUBTYPE <sName>_index is integer range 1..<nCMax>;
SUBTYPE <sName> IS String(<sName>_index);
<if(arrnAlphaChars)>
SUBTYPE <sName>_alpha_index is integer range 1..<arrnAlphaChars.Length>;
SUBTYPE <sName>_alpha IS String(<sName>_alpha_index);
<sName>_alpha_set : constant <sName>_alpha := <sName>_alpha'(<arrnAlphaChars:{c|<i>=>Character'Val(<c>)}; wrap, anchor,  separator=", ">);

<endif>
>>

Define_SubType_ia5string(sTypeDefinitionName, soParentTypePackage, sParentType, arrnAlphaChars) ::= <<
SUBTYPE <sTypeDefinitionName>_encoding_range is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_encoding_range;
SUBTYPE <sTypeDefinitionName>_index is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_index;
<if(arrnAlphaChars)>
SUBTYPE <sTypeDefinitionName>_alpha_index is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_alpha_index;
SUBTYPE <sTypeDefinitionName>_alpha <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_alpha;
<sTypeDefinitionName>_alpha_set : constant := <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_alpha_set;

<endif>

>>


ENUMERATED_tas_decl_item(sName, nValue) ::= "<sName> => <nValue>"
ENUMERATED_tas_decl(sName, arrsEnumNames, arrsEnumNamesAndValues, nIndexMax) ::= <<
SUBTYPE <sName>_index_range is integer range 0..<nIndexMax>;
TYPE <sName> IS (<arrsEnumNames; separator=", ">) with Convention => C;
for <sName> use
    (<arrsEnumNamesAndValues; separator=", ">);
>>

Define_SubType_enumerated(sTypeDefinitionName, soParentTypePackage, sParentType) ::= <<
SUBTYPE <sTypeDefinitionName>_index_range is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>_index_range;
>>


UPER_annotations_encode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
--# derives S from S , K, val & K from K<if(bKDependsOnValue)>, val<endif><if(bAcnEncodeFuncRequiresResult)> & result from val <endif>;
--# pre K+1>= S'First and K + <sName>_REQUIRED_BITS_FOR_ENCODING \<= S'Last;
--# post K>=K~ and K\<=K~+<sName>_REQUIRED_BITS_FOR_ENCODING;
>>
UPER_annotations_decode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
--# derives val from S , K &
--#         K from K <if(bKDependsOnData)>,S<endif> & result from K<if(bResDependsOnData)>,S<endif>;
--# pre K.K+1>= S'First and K.K + <sName>_REQUIRED_BITS_FOR_ENCODING \<= S'Last;
--# post K.K>=K~.K and K.K\<=K~.K+<sName>_REQUIRED_BITS_FOR_ENCODING;
>>



UPER_encPrototypes(sName, bEmptyEncodingSpace, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData) ::= <<
SUBTYPE <sName>_uPER_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sName>_REQUIRED_BITS_FOR_ENCODING<endif>;
SUBTYPE <sName>_uPER_bit_array is <rtlModuleName()>.BitArray(<sName>_uPER_bit_array_range);

TYPE <sName>_uPER_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sName>_uPER_bit_array;
END RECORD;
PROCEDURE <sName>_uPER_Encode(val:in <sName>; Stream : OUT <sName>_uPER_Stream<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
--# derives Stream from val<if(bAcnEncodeFuncRequiresResult)> & result from val <endif>;
PROCEDURE <sName>_uPER_Decode(val: out <sName>; Stream : IN <sName>_uPER_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT);
--# derives val from Stream & result from Stream;

PROCEDURE <sName>_uPER_Encode_aux(val:in <sName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
<UPER_annotations_encode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult= bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData)>
PROCEDURE <sName>_uPER_Decode_aux(val: out <sName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT);
<UPER_annotations_decode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult= bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData)>
>>



ExtraParams(extraPrms) /*nogen*/ ::= "<if(extraPrms)>, <extraPrms; separator=\", \"><endif>"

/* arrsEncDecInOutPrmsNames */

ACN_encPrototypes(sName, bEmptyEncodingSpace, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsExtraEncParams, arrsExtraDecParams, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools, arrsUpdatePrototypes) ::= <<
SUBTYPE <sName>_ACN_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sName>_REQUIRED_BITS_FOR_ACN_ENCODING<endif>;
SUBTYPE <sName>_ACN_bit_array is <rtlModuleName()>.BitArray(<sName>_ACN_bit_array_range);

TYPE <sName>_ACN_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sName>_ACN_bit_array;
END RECORD;
PROCEDURE <sName>_ACN_Encode(val:in <sName>; Stream : OUT <sName>_ACN_Stream<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif><if(arrsExtraEncParams)>; <arrsExtraEncParams;separator="; "><endif>);
--# derives Stream from val<ExtraParams(arrsEncDecInOutPrmsNames)> <if(bAcnEncodeFuncRequiresResult)>& result from val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif>;
PROCEDURE <sName>_ACN_Decode(val: out <sName>; Stream : IN <sName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsExtraDecParams)>; <arrsExtraDecParams;separator="; "><endif>);
--# derives val<ExtraParams(arrsEncDecInOutPrmsNames)> from Stream<ExtraParams(arrsDecInParamNames)> & result from Stream<ExtraParams(arrsDecInParamNames)>;

PROCEDURE <sName>_ACN_Encode_aux(val:in <sName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural<if(bAcnEncodeFuncRequiresResult)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif><if(arrsExtraEncParams)>; <arrsExtraEncParams;separator="; "><endif>);
<ACN_annotations_encode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult=bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData, arrsEncDecInOutPrmsNames=arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools=arrsEncDecInOutPrmsNames_noBools)>

PROCEDURE <sName>_ACN_Decode_aux(val: out <sName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsExtraDecParams)>; <arrsExtraDecParams;separator="; "><endif>);
<ACN_annotations_decode(sName=sName, bKDependsOnValue=bKDependsOnValue, bAcnEncodeFuncRequiresResult=bAcnEncodeFuncRequiresResult, bResDependsOnData=bResDependsOnData, bKDependsOnData=bKDependsOnData, arrsDecInParamNames=arrsDecInParamNames, arrsEncDecInOutPrmsNames=arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools=arrsEncDecInOutPrmsNames_noBools)>

<arrsUpdatePrototypes; separator="\n\n">
>>

ACN_annotations_encode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools) ::= <<
--# derives   S from S , K, val<ExtraParams(arrsEncDecInOutPrmsNames)> & 
--#           K from K<if(bKDependsOnValue)>, val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif><if(bAcnEncodeFuncRequiresResult)> & result from val<ExtraParams(arrsEncDecInOutPrmsNames_noBools)><endif>;
--# pre K+1>= S'First and K + <sName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last;
--# post K>=K~ and K\<=K~+<sName>_REQUIRED_BITS_FOR_ACN_ENCODING;
>>

ACN_annotations_decode(sName, bKDependsOnValue, bAcnEncodeFuncRequiresResult, bResDependsOnData, bKDependsOnData, arrsDecInParamNames, arrsEncDecInOutPrmsNames, arrsEncDecInOutPrmsNames_noBools) ::= <<
--# derives val<ExtraParams(arrsEncDecInOutPrmsNames)>      from S, K<ExtraParams(arrsDecInParamNames)> &
--#         K        from K<if(bKDependsOnData)>, S<endif><ExtraParams(arrsDecInParamNames)> & 
--#         result   from K<if(bResDependsOnData)>, S<endif><ExtraParams(arrsDecInParamNames)>;
--# pre K.K+1>= S'First and K.K + <sName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last;
--# post K.K>=K~.K and K.K\<=K~.K+<sName>_REQUIRED_BITS_FOR_ACN_ENCODING;
---- bKDependsOnData = <bKDependsOnData>
>>


Acn_update_param_protorype(sTasName, bHasSuccess, sParamName, sParamType) ::= <<
PROCEDURE <sTasName>_ACN_Encode_update_<sParamName>(val : IN <sTasName>; <sParamName>: OUT <sParamType><if(bHasSuccess)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>);
--# derives <sParamName><if(bHasSuccess)>, result<endif> from val;
>>



PrintErrorCode(sErrorName, nErrCode, sComment) ::= "<sErrorName>:CONSTANT INTEGER := <nErrCode>; -- <sComment>"

Declare_spark_Integer() ::="<rtlModuleName()>.Asn1Int"

Declare_IntegerNoRTL() ::="Asn1Int"
Declare_PosIntegerNoRTL() ::="Asn1UInt"

Declare_Integer() ::="<rtlModuleName()>.Asn1Int"
Declare_PosInteger() ::="<rtlModuleName()>.Asn1UInt"

Declare_PosInteger_min_max(nMin, nMax) ::="<rtlModuleName()>.Asn1UInt range <nMin>..<nMax>"
Declare_PosInteger_posInf(nMin) ::="<rtlModuleName()>.Asn1UInt range <nMin>..<rtlModuleName()>.Asn1UInt'Last"


Declare_Integer_min_max(nMin, nMax) ::="<rtlModuleName()>.Asn1Int range <nMin>..<nMax>"
Declare_Integer_posInf(nMin) ::="<rtlModuleName()>.Asn1Int range <nMin>..<rtlModuleName()>.Asn1Int'Last"
Declare_Integer_negInf(nMax) ::="<rtlModuleName()>.Asn1Int range <rtlModuleName()>.Asn1Int'First..<nMax>"


Declare_BOOLEAN() ::= "<rtlModuleName()>.Asn1Boolean"
Declare_REAL() ::= "<rtlModuleName()>.Asn1Real"
Declare_NULL() ::= "<rtlModuleName()>.Asn1NullType"

Declare_BOOLEANNoRTL() ::= "Asn1Boolean"
Declare_REALNoRTL() ::= "Asn1Real"
Declare_NULLNoRTL() ::= "Asn1NullType"

Declare_Reference1(sName) ::= "<sName>"
Declare_Reference2(sModName,sName) ::= "<sModName>.<sName>"



Define_SubType_int_range(soParentTypePackage, sParentType, noMin, noMax) ::= <<
range <if(noMin)><noMin><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'First<endif> .. <if(noMax)><noMax><else><if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType>'Last<endif>
>>


Define_SubType(sTypeDefinitionName, soParentTypePackage, sParentType, soNewRange, soExtraDefs) ::= <<
SUBTYPE <sTypeDefinitionName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><sParentType><if(soNewRange)> <soNewRange><endif>;
<soExtraDefs>
>>


/***********************************************************************************************/
Define_new_ia5string(td/*:FE_StringTypeDefinition*/, nMin, nMax, nCMax, arrnAlphaChars) ::= <<
SUBTYPE <td.encoding_range> is integer range <nMin>..<nMax>;
SUBTYPE <td.index> is integer range 1..<nCMax>;
SUBTYPE <td.typeName> IS String(<td.index>);
<if(arrnAlphaChars)>
SUBTYPE <td.alpha_index> is integer range 1..<arrnAlphaChars.Length>;
SUBTYPE <td.alpha> IS String(<td.alpha_index>);
<td.alpha_set> : constant <td.alpha> := <td.alpha>'(<arrnAlphaChars:{c|<i>=>Character'Val(<c>)}; wrap, anchor,  separator=", ">);

<endif>
>>




Define_subType_ia5string(td/*:FE_StringTypeDefinition*/, prTd/*:FE_StringTypeDefinition*/, soParentTypePackage) ::= <<

SUBTYPE <td.typeName> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.typeName>

SUBTYPE <td.encoding_range> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.encoding_range>;
SUBTYPE <td.index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.index>;
<if(arrnAlphaChars)>
SUBTYPE <td.alpha_index> is <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_index>;
SUBTYPE <td.alpha> <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha>;
<td.alpha_set> : constant := <if(soParentTypePackage)><soParentTypePackage>.<endif><prTd.alpha_set>;

<endif>

>>
