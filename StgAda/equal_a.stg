group a_equals;


JoinItems(sPart, soNestedPart) ::= <<
<sPart>
<if(soNestedPart)>
if ret then
    <soNestedPart>
end if;
<endif>
>>


PrintEqualDefintion(sFuncName, sTypeDefName) ::= <<
function <sFuncName>(val1, val2: in <sTypeDefName>) return Boolean;
>>

PrintEqualPrimitive(sFuncName, sTypeDefName, sContent) ::= <<
function <sFuncName>(val1, val2: in <sTypeDefName>) 
    return Boolean is
begin
    return <sContent>;
end <sFuncName>;
>>

PrintEqualComposite(sFuncName, sTypeDefName, sContent, arrsLocalVars) ::= <<
function <sFuncName>(val1, val2: in <sTypeDefName>) 
    return Boolean 
is
    ret : Boolean := TRUE;
    <arrsLocalVars; separator="\n">
begin
    <sContent>
    return ret;
end <sFuncName>;
>>


CHOICE_setters_body_child(sTasName, sName, sType, sNamePresent) ::= <<
FUNCTION <sTasName>_<sName>_get(val:<sTasName>) RETURN <sType>
IS --# hide <sTasName>_<sName>_get;
BEGIN
    RETURN val.<sName>;
END <sTasName>_<sName>_get;

FUNCTION <sTasName>_<sName>_set(itm:<sType>) RETURN <sTasName>
IS --# hide <sTasName>_<sName>_set;
BEGIN
    RETURN <sTasName>'(kind => <sNamePresent>, <sName> => itm);
END <sTasName>_<sName>_set;
>>


CHOICE_setters_body(sTasName, arrsChildren) ::= <<
FUNCTION <sTasName>_kind(val:<sTasName>) RETURN <sTasName>_selection 
IS --# hide <sTasName>_kind;
BEGIN
    return val.kind;
END <sTasName>_kind;

<arrsChildren; separator="\n">


>>



PrintTypeAssignment(sName, sInitBody, bContainsChoice) ::= <<
FUNCTION <sName>_Init return <sName>
IS <if(bContainsChoice)>--#hide <sName>_Init;<endif>
BEGIN
    RETURN <sInitBody>;
END <sName>_Init;
>>

/*
 *****************************************************************************************
               E Q U A L I T Y     F U N C T I O N S
 *****************************************************************************************
 */
PrimitiveEqual(p1,p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Integer(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Real(p1, p2) ::= <<
begin
    return Asn1Real_Equal(<p1>, <p2>);
>>


isEqual_IA5String(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_NumericString(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_OctetString(p1, p2, bFixedSize, nFixedSize) ::= <<
<if(!bFixedSize)><p1>Length = <p2>Length and then <endif><p1>Data(1 .. <p1>Length) = <p2>Data(1 .. <p2>Length)
>>


isEqual_NullType() ::= <<
begin
    return True;
>>


isEqual_BitString(p1,p2,bFixedSize,nFixedSize) ::= <<
<isEqual_OctetString(p1=p1,p2=p2, bFixedSize=bFixedSize, nFixedSize=nFixedSize)>
>>

isEqual_Boolean(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_Enumerated(p1, p2) ::= <<
begin
    return <p1> = <p2>;
>>


isEqual_SequenceOf(p1,p2, i, bIsFixedSize, nFixedSize, soInnerStatement) ::= <<
<if(!bIsFixedSize)>
ret := (<p1>.Length = <p2>.Length);

<endif>
<if (soInnerStatement)>
if ret then
    for <i> in integer  range 1 .. <p1>.Length loop
	    <soInnerStatement>
    end loop;
end if;

<endif>
>>


isEqual_Choice_Child(p1, p2, sCid, sAsn1Id, sInnerType, sTasName, sInnerTypeName) ::= <<
(if <sTasName>_kind(<p1>) = <sCid> then
 <sInnerTypeName>_Equal(<sTasName>_<sAsn1Id>_get(<p1>), <sTasName>_<sAsn1Id>_get(<p2>)) else False)
>>


isEqual_Choice(p1,p2, arrsChildren, sTasName) ::= <<
begin
    return <sTasName>_kind(<p1>) = <sTasName>_kind(<p2>) and then
    (<arrsChildren; separator=" or \n">);

>>


isEqual_Sequence_Child(p1, p2, bIsOptional, sChName, soInnerStatement) ::= <<
<if(bIsOptional)>
ret := <p1>.Exist.<sChName> = <p2>.Exist.<sChName>;
<if(soInnerStatement)>
if ret and then <p1>.Exist.<sChName> = 1 then
    <soInnerStatement>
end if;

<endif>

<else>
<soInnerStatement>

<endif>
>>


isEqual_Sequence(p1, p2, arrsChildren) ::= <<
begin
    return <if(arrsChildren)><arrsChildren; separator=" and "><else>true<endif>;
>>


isEqual_ReferenceType(sPtr1, sPtr2, sName) ::= <<
begin
    return <sName>_Equal(<sPtr1>, <sPtr2>);
>>


