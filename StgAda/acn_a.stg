group a_acn;

rtlModuleName() ::= "adaasn1rtl"

EmitAcnParameter(sName, sType) ::= "<sName> : IN <sType>"

EmitTypeAssignment_def_err_code(sErrCode, nErrValue) ::= <<
<sErrCode>:CONSTANT INTEGER := <nErrValue>; 
>>

EmitTypeAssignment_primitive_def_encode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms) ::= <<
<arrsErrcodes; separator="\n">
<sTypeDefName>_REQUIRED_BYTES_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBytesInACN>;
<sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING:CONSTANT INTEGER := <nMaxBitsInACN>;

SUBTYPE <sTypeDefName>_ACN_bit_array_range is Natural range 1..<if(bEmptyEncodingSpace)>1<else><sTypeDefName>_REQUIRED_BITS_FOR_ACN_ENCODING<endif>;
SUBTYPE <sTypeDefName>_ACN_bit_array is <rtlModuleName()>.BitArray(<sTypeDefName>_ACN_bit_array_range);


TYPE <sTypeDefName>_ACN_Stream IS RECORD
    K	: Natural;
    DataLen	: Natural;
    Data : <sTypeDefName>_ACN_bit_array;
end RECORD;

procedure <sFuncName>(val:in <sTypeDefName>; Stream : OUT <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT);
>>

EmitTypeAssignment_primitive_encodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= /*nogen*/<<
PROCEDURE <sFuncName>(<sVarName>:in <sTypeDefName>; Stream : OUT <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT)
IS
BEGIN
    Stream := <sTypeDefName>_ACN_Stream'(K => 0, DataLen => 0, Data => <sTypeDefName>_ACN_bit_array'(others => 0));
    <sTypeDefName>_ACN_Encode_aux(<sVarName>, Stream.Data, Stream.DataLen, result);
END <sFuncName>;
>>

EmitTypeAssignment_primitive_encode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= <<
PROCEDURE <sFuncName>_aux(<sVarName>:in <sTypeDefName>; S : in out <rtlModuleName()>.BitArray; K : in out Natural; result : OUT <rtlModuleName()>.ASN1_RESULT)
<soSparkAnnotations>
IS
    <arrsLocalVariables; separator="\n">
BEGIN
    <if(soIValidFuncName)>
    result := <soIValidFuncName>(<sVarName>);
    IF result.success THEN
        <sContent>
    END IF;
    <else>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
    <sContent>
    <endif>
END <sFuncName>_aux;


<EmitTypeAssignment_primitive_encodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitilialExp=sInitilialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames)>
>>



EmitTypeAssignment_primitive_def_decode(sVarName, sStar, sFuncName, sTypeDefName, arrsErrcodes, bEmptyEncodingSpace, nMaxBytesInACN, nMaxBitsInACN, arrsAcnPrms) ::= <<
<arrsErrcodes; separator="\n">
procedure <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : IN <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>);
>>

EmitTypeAssignment_primitive_decodeMain(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= /*nogen*/<<
PROCEDURE <sFuncName>(<sVarName>: out <sTypeDefName>; Stream : IN <sTypeDefName>_ACN_Stream; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
IS
    iter:<rtlModuleName()>.DECODE_PARAMS;
BEGIN
    iter := <rtlModuleName()>.DECODE_PARAMS'(K => 0, DataLen => Stream.DataLen);
    <sFuncName>_aux(<sVarName>, Stream.Data, iter, result<if(arrsAcnParamNames)>, <arrsAcnParamNames; separator=","><endif>);
    result.Success := result.Success AND iter.K\<=iter.DataLen;
END <sFuncName>;
>>

EmitTypeAssignment_primitive_decode(sVarName, sStar, sFuncName, soIValidFuncName, sTypeDefName, arrsLocalVariables, sContent, soSparkAnnotations, sInitilialExp, arrsAcnPrms, arrsAcnParamNames) ::= <<
pragma Warnings (Off, "unused initial value of ""<sVarName>""");
PROCEDURE <sFuncName>_aux(<sVarName>:out <sTypeDefName>; S : in <rtlModuleName()>.BitArray; K : in out <rtlModuleName()>.DECODE_PARAMS; result : OUT <rtlModuleName()>.ASN1_RESULT<if(arrsAcnPrms)>; <arrsAcnPrms; separator="; "><endif>)
<soSparkAnnotations>
IS
    <arrsLocalVariables; separator="\n">
BEGIN
    <sContent>
END <sFuncName>_aux;
pragma Warnings (On, "unused initial value of ""<sVarName>""");

<EmitTypeAssignment_primitive_decodeMain(sVarName=sVarName, sStar=sStar, sFuncName=sFuncName, soIValidFuncName=soIValidFuncName, sTypeDefName=sTypeDefName, arrsLocalVariables=arrsLocalVariables, sContent=sContent, soSparkAnnotations=soSparkAnnotations, sInitilialExp=sInitilialExp, arrsAcnPrms=arrsAcnPrms, arrsAcnParamNames=arrsAcnParamNames)>
>>





MF(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin> AND <p> \<= <nUperMax>;
    IF NOT Result.Success THEN
        <p> := <nUperMin>;
        Result.ErrorCode := ERR_INCORRECT_STREAM;
    END IF;
END IF;
>>

MFen(soMF, soMFM, p) ::= "<if(soMF)><soMFM>.<soMF>_encode(<p>)<else><p><endif>"

PositiveInteger_ConstSize_encode(p, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);
>>

PositiveInteger_ConstSize_decode(p, nFixedSize, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize(S, K, mapFuncIntVal, 0, 0, Asn1Int(2)**<nFixedSize> - 1, <nFixedSize>, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);

<endif>
>>

PositiveInteger_ConstSize_8_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_8(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_8_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_8(S, K, mapFuncIntVal, 0, 0, Asn1Int(255), result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_8(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

PositiveInteger_ConstSize_big_endian_16_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_16_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(S, K, mapFuncIntVal, 0, 0, Asn1Int(65535), result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);
<endif>
>>


PositiveInteger_ConstSize_big_endian_32_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_32_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

PositiveInteger_ConstSize_big_endian_64_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_big_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_big_endian_64_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_big_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

PositiveInteger_ConstSize_little_endian_16_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_16_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

PositiveInteger_ConstSize_little_endian_32_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_32_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last,  result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_32(S, K, <p>, <nUperMin>, <nUperMax>,  result);

<endif>
>>

PositiveInteger_ConstSize_little_endian_64_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_ConstSize_little_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_ConstSize_little_endian_64_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(S, K, mapFuncIntVal, 0, 0, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_ConstSize_little_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

PositiveInteger_VarSize_LengthEmbedded_encode(p, soMF, soMFM, nUperMin) ::= "<rtlModuleName()>.Acn_Enc_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
PositiveInteger_VarSize_LengthEmbedded_decode(p, soMF, soMFM, nUperMin) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, mapFuncIntVal, 0, 0, result);
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
    Result.Success := <p> \>= <nUperMin>;
    IF NOT Result.Success THEN
        <p> := <nUperMin>;
        Result.ErrorCode := ERR_INCORRECT_STREAM;
    END IF;
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_PositiveInteger_VarSize_LengthEmbedded(S, K, <p>, <nUperMin>, result);

<endif>
>>


TwosComplement_ConstSize_encode(p, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nFixedSize>);"
TwosComplement_ConstSize_decode(p, soMF, soMFM, nFixedSize, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nFixedSize>, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nFixedSize>, result);

<endif>
>>

TwosComplement_ConstSize_8_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_8(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_8_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_8(S, K, mapFuncIntVal, -Asn1Int(128), Asn1Int(127), result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_8(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_big_endian_16_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_16_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_big_endian_32_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_32_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_big_endian_64_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_big_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_big_endian_64_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_big_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_little_endian_16_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_16(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_16_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_16(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_little_endian_32_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_32(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_32_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_32(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_ConstSize_little_endian_64_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_ConstSize_little_endian_64(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_ConstSize_little_endian_64_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_ConstSize_little_endian_64(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

TwosComplement_VarSize_LengthEmbedded_encode(p,soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
TwosComplement_VarSize_LengthEmbedded_decode(p,soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <p>, result);
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_TwosComplement_VarSize_LengthEmbedded(S, K, <p>, result);

<endif>
>>


BCD_ConstSize_encode(p, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nNibbles>);"
BCD_ConstSize_decode(p, soMF, soMFM, nUperMin, nUperMax, nNibbles) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nNibbles>, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nNibbles>, result);

<endif>
>>

BCD_VarSize_LengthEmbedded_encode(p, soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_LengthEmbedded_decode(p, soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_LengthEmbedded(S, K, mapFuncIntVal, result);
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_LengthEmbedded(S, K, <p>, result);

<endif>
>>

BCD_VarSize_NullTerminated_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_BCD_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
BCD_VarSize_NullTerminated_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_NullTerminated(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_BCD_VarSize_NullTerminated(S, K, <p>, <nUperMin>, <nUperMax>, result);

<endif>
>>

ASCII_ConstSize_encode(p, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_ConstSize_decode(p, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);

<endif>
>>


ASCII_UINT_ConstSize_encode(p, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= "<rtlModuleName()>.Acn_Enc_UInt_ASCII_ConstSize(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>, <nSizeInBytes>);"
ASCII_UINT_ConstSize_decode(p, soMF, soMFM, nUperMin, nUperMax, nSizeInBytes) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_ConstSize(S, K, mapFuncIntVal, Asn1Int'First, Asn1Int'Last, <nSizeInBytes>, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_ConstSize(S, K, <p>, <nUperMin>, <nUperMax>, <nSizeInBytes>, result);

<endif>
>>



ASCII_VarSize_LengthEmbedded_encode(p, soMF, soMFM) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_VarSize_LengthEmbedded(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
ASCII_VarSize_LengthEmbedded_decode(p, soMF, soMFM) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded(S, K, mapFuncIntVal, result);
IF Result.Success THEN
    <p> := <soMFM>.<soMF>_decode(mapFuncIntVal);
END IF;

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_LengthEmbedded(S, K, <p>, result);

<endif>
>>

ASCII_VarSize_NullTerminated_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_Int_ASCII_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
ASCII_VarSize_NullTerminated_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_NullTerminated(S, K, mapFuncIntVal, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_Int_ASCII_VarSize_NullTerminated(S, K, <p>, result);

<endif>
>>


ASCII_UINT_VarSize_NullTerminated_encode(p, soMF, soMFM, nUperMin, nUperMax) ::= "<rtlModuleName()>.Acn_Enc_UInt_ASCII_VarSize_NullTerminated(S, K, <MFen(soMF=soMF, soMFM=soMFM, p=p)>);"
ASCII_UINT_VarSize_NullTerminated_decode(p, soMF, soMFM, nUperMin, nUperMax) ::= <<
<if(soMF)>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_VarSize_NullTerminated(S, K, mapFuncIntVal, result);
<MF(p=p, soMF=soMF, soMFM=soMFM, nUperMin=nUperMin, nUperMax=nUperMax)>

<else>
<rtlModuleName()>.Acn_Dec_UInt_ASCII_VarSize_NullTerminated(S, K, <p>, result);

<endif>
>>


/************************ OLD macros ***********************************************************************/




PrintType_encode(sMainBody, bAligmentApplied, nAligmentValue, bHasDependencies, sDependencyUpdates) ::= <<
<if(bAligmentApplied)>
IF (K MOD <nAligmentValue>) /= 0 THEN
    K := K + (<nAligmentValue> - (K MOD <nAligmentValue>));
END IF;

<endif>
<if(bHasDependencies)>
<sDependencyUpdates>

<endif>
<sMainBody>
>>


PrintType_decode(sMainBody, bAligmentApplied, nAligmentValue, bHasDependencies, sDependencyUpdates) ::= <<
<if(bAligmentApplied)>
IF (K.K MOD <nAligmentValue>) /= 0 THEN
    K.K := K.K + (<nAligmentValue> - (K.K MOD <nAligmentValue>));
END IF;

<endif>
<sMainBody>
>>


Real_32_big_endian_encode(p) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_32_big_endian(S, K, <p>);"
Real_32_big_endian_decode(p) ::= "<rtlModuleName()>.Acn_Dec_Real_IEEE754_32_big_endian(S, K, <p>, result);"

Real_64_big_endian_encode(p) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_64_big_endian(S, K, <p>);"
Real_64_big_endian_decode(p) ::= "<rtlModuleName()>.Acn_Dec_Real_IEEE754_64_big_endian(S, K, <p>, result);"

Real_32_little_endian_encode(p) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_32_little_endian(S, K, <p>);"
Real_32_little_endian_decode(p) ::= "<rtlModuleName()>.Acn_Dec_Real_IEEE754_32_little_endian(S, K, <p>, result);"

Real_64_little_endian_encode(p) ::= "<rtlModuleName()>.Acn_Enc_Real_IEEE754_64_little_endian(S, K, <p>);"
Real_64_little_endian_decode(p) ::= "<rtlModuleName()>.Acn_Dec_Real_IEEE754_64_little_endian(S, K, <p>, result);"




Boolean_encode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
<rtlModuleName()>.Acn_Enc_Boolean_true_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));

<else>
<rtlModuleName()>.Acn_Enc_Boolean_false_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));

<endif>
>>

Boolean_decode(p, ptr, bTruePattern, nSize, arruTrueValueAsByteArray, arruFalseValueAsByteArray, arrsBits, sErrCode) ::= <<
<if(bTruePattern)>
<rtlModuleName()>.Acn_Dec_Boolean_true_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);

<else>
<rtlModuleName()>.Acn_Dec_Boolean_false_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);

<endif>
result.ErrorCode := <sErrCode>;
>>


Null_pattern_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Enc_NullType_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_NullType_pattern(S, K, <p>, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;
>>



Null_pattern2_encode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Enc_NullType_pattern2(S, K, BitArray'(<arrsBits; separator=",">));
>>

Null_pattern2_decode(p, arruNullValueAsByteArray, nSize, arrsBits, sErrCode) ::= <<
<rtlModuleName()>.Acn_Dec_NullType_pattern2(S, K, BitArray'(<arrsBits; separator=",">), result);
result.ErrorCode := <sErrCode>;
>>


Null2_encode() ::= <<
 -- encoding NULL, nothing to do
>>

Null2_decode() ::= <<
 -- decoding NULL, nothing to do
>>


Null_encode(p) ::= <<
<rtlModuleName()>.Acn_Enc_NullType(S, K, <p>);
>>

Null_decode(p) ::= <<
<rtlModuleName()>.Acn_Dec_NullType(S, K, <p>, result);
>>




Enumerated_item_encode(p, sName, nItemIdxOrVal) ::= "when <sName>    => intVal := <nItemIdxOrVal>;"

Enumerated_item_decode(p, sName, nItemIdxOrVal) ::= "when <nItemIdxOrVal> => <p> := <sName>;"

EnumeratedEncIdx_encode(p, sTasName, arrsItem, sActualCodecFunc) ::= <<
case <p> is 
    <arrsItem; separator="\n">
end case;
<sActualCodecFunc>
>>

EnumeratedEncIdx_decode(p, sTasName, arrsItem, sActualCodecFunc) ::= <<
<p> := <sTasName>_Init;
<sActualCodecFunc>
IF result.Success THEN
    case <sTasName>_index_range(intVal) is
        <arrsItem; separator="\n">
    end case;
END IF;
>>


EnumeratedEncValues_encode(p, sTasName, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName) ::= <<
<EnumeratedEncIdx_encode(p=p, sTasName=sTasName, arrsItem=arrsItem, sActualCodecFunc=sActualCodecFunc)>
>>

EnumeratedEncValues_decode(p, sTasName, arrsItem, sActualCodecFunc, sErrCode, sFirstItemName) ::= <<
<sActualCodecFunc>
if result.Success then
    case intVal is
        <arrsItem; separator="\n">
    when others =>
        <p> := <sFirstItemName>;
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
    end case;
else
    <p> := <sFirstItemName>;
    result.ErrorCode := <sErrCode>;
end if;
>>


// Strings



Acn_String_Ascii_FixSize_encode(p, nAsn1Max) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_FixSize(S, K, <p>);"
Acn_String_Ascii_FixSize_decode(p, nAsn1Max) ::= "<rtlModuleName()>.Acn_Dec_String_Ascii_FixSize(S, K, <p>, result);"

Acn_String_Ascii_Null_Teminated_encode(p, nAsn1Max, sNull) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_Null_Teminated(S, K, <sNull>, <p>);"
Acn_String_Ascii_Null_Teminated_decode(p, nAsn1Max, sNull) ::= "<rtlModuleName()>.Acn_Dec_String_Ascii_Null_Teminated(S, K, <sNull>, <p>, result);"

Acn_String_Ascii_External_Field_Determinant_encode(p, nAsn1Max, sExtFld) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_External_Field_Determinant(S, K, <p>);"
Acn_String_Ascii_External_Field_Determinant_decode(p, nAsn1Max, sExtFld) ::= "<rtlModuleName()>.Acn_Dec_String_Ascii_External_Field_Determinant(S, K, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);"

Acn_String_Ascii_Internal_Field_Determinant_encode(p, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Enc_String_Ascii_Internal_Field_Determinant(S, K, <nAsn1Min>, <nInternalLengthDeterminantSizeInBits>, <p>);"
Acn_String_Ascii_Internal_Field_Determinant_decode(p, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Dec_String_Ascii_Internal_Field_Determinant(S, K, <nAsn1Min>, <nAsn1Max>, <nInternalLengthDeterminantSizeInBits>, <p>, result);"


Acn_String_CharIndex_FixSize_encode(p, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sTasName, nCharSize) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_FixSize(S, K, <sTasName>_alpha_set, <nCharSize>, <p>);"
Acn_String_CharIndex_FixSize_decode(p, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sTasName, nCharSize) ::= "<rtlModuleName()>.Acn_Dec_String_CharIndex_FixSize(S, K, <sTasName>_alpha_set, <nCharSize>, <p>, result);"

Acn_String_CharIndex_External_Field_Determinant_encode(p, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, sTasName, nCharSize) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_External_Field_Determinant(S, K, <sTasName>_alpha_set, <nCharSize>, <p>);"
Acn_String_CharIndex_External_Field_Determinant_decode(p, nAsn1Max, arrnAlphabetAsciiCodes, nCharSetSize, sExtFld, sTasName, nCharSize) ::= "<rtlModuleName()>.Acn_Dec_String_CharIndex_External_Field_Determinant(S, K, <sTasName>_alpha_set, <nCharSize>, <rtlModuleName()>.Asn1Int(<sExtFld>), <p>, result);"

Acn_String_CharIndex_Internal_Field_Determinant_encode(p, sTasName, nCharSize, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Enc_String_CharIndex_Internal_Field_Determinant(S, K, <sTasName>_alpha_set, <nCharSize>, <nAsn1Min>, <nInternalLengthDeterminantSizeInBits>, <p>);"
Acn_String_CharIndex_Internal_Field_Determinant_decode(p, sTasName, nCharSize, nAsn1Max, nAsn1Min, nInternalLengthDeterminantSizeInBits) ::= "<rtlModuleName()>.Acn_Dec_String_CharIndex_Internal_Field_Determinant(S, K, <sTasName>_alpha_set, <nCharSize>, <nAsn1Min>, <nAsn1Max>, <nInternalLengthDeterminantSizeInBits>, <p>, result);"




PrintTypeNoUpdate_encode(sMainBody, bAligmentApplied, nAligmentValue) ::= <<
<PrintType_encode(sMainBody=sMainBody, bAligmentApplied=bAligmentApplied, nAligmentValue=nAligmentValue)>
>>
PrintTypeNoUpdate_decode(sMainBody, bAligmentApplied, nAligmentValue) ::= <<
<PrintType_decode(sMainBody=sMainBody, bAligmentApplied=bAligmentApplied, nAligmentValue=nAligmentValue)>
>>

loopFixedItem_enc (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<    
<i> := 1;
while <i>\<= <fixedSize> loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (K >= K'Loop_Entry);
    pragma Loop_Invariant (K\<=K'Loop_Entry + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>

loopFixedItem_dec (i, fixedSize, nfixedSizeUperLimit, sInternalItem, nCurOffset, nAlignSize, nIntItemMinSize, nIntItemMaxSize)::= /*nogen*/<<    
<i> := 1;
while <i>\<= <fixedSize> AND result.Success loop
    pragma Loop_Invariant (<i> >=1 and <i>\<=<fixedSize>);
    pragma Loop_Invariant (K.K >= K'Loop_Entry.K);
    pragma Loop_Invariant (K.K \<= K'Loop_Entry.K + <nIntItemMaxSize>*(<i>-1));
    <sInternalItem>
    <i> := <i> + 1;
end loop;
>>



/* Strings */



string_InternalItem_encode(p, i) ::=<<
charIndex := <rtlModuleName()>.CharacterPos(<p>(<i>));
<rtlModuleName()>.UPER_Enc_ConstraintWholeNumber(S, K, <rtlModuleName()>.Asn1Int(charIndex), 0, 7);
>>


string_InternalItem_decode(p, i) ::=<<
<rtlModuleName()>.UPER_Dec_ConstraintWholeNumberInt(S, K, charIndex, 0, 127, 7, result.Success);
<p>(<i>) := Character'Val(charIndex);
>>


str_FixedSize_encode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize, nfixedSizeUperLimit = nFixedSize, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>

str_FixedSize_decode(p, sTasName, i, sInternalItem, nFixedSize, nIntItemMinSize, nIntItemMaxSize, nAlignSize) ::= <<
val := <sTasName>_Init;
result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
<loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=nFixedSize, nfixedSizeUperLimit = nFixedSize, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>

str_VarSize_encode(p, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize) ::= <<
length := <rtlModuleName()>.getStringSize(<p>);
result.Success := length >= <nSizeMin> AND length \<= <nSizeMax>;
IF result.Success THEN
    <rtlModuleName()>.UPER_Enc_ConstraintWholeNumber(S, K, <rtlModuleName()>.Asn1Int(length), <nSizeMin>, <nSizeInBits>);
    <loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize="length", nfixedSizeUperLimit = nSizeMax, nCurOffset=nSizeInBits, nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
END IF;
>>

str_VarSize_decode(p, sTasName, i, sInternalItem, nSizeMin, nSizeMax, nSizeInBits, nIntItemMinSize, nIntItemMaxSize, nAlignSize) ::= <<
val := <sTasName>_Init;
result.ErrorCode := <rtlModuleName()>.ERR_INSUFFICIENT_DATA; 
<rtlModuleName()>.UPER_Dec_ConstraintWholeNumberInt(S, K, length, <nSizeMin>, <nSizeMax>, <nSizeInBits>, result.Success);
<loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize="length", nfixedSizeUperLimit = nSizeMax, nCurOffset=nSizeInBits, nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


str_external_field_encode(p, sTasName, i, sInternalItem, nSizeMin, nSizeMax,  nIntItemMinSize, nIntItemMaxSize, sExtFld, nAlignSize) ::= <<
length := <rtlModuleName()>.getStringSize(<p>);
result.Success := length >= <nSizeMin> AND length \<= <nSizeMax>;
IF result.Success THEN
    <loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize="length", nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
END IF;
>>

str_external_field_decode(p, sTasName, i, sInternalItem, nSizeMin, nSizeMax,  nIntItemMinSize, nIntItemMaxSize, sExtFld, nAlignSize) ::= <<
val := <sTasName>_Init;
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sExtFld> >= <nSizeMin> AND <sExtFld>\<=<nSizeMax>, ErrorCode => 0);
<loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=["Integer(",sExtFld,")"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>





oct_sqf_external_field_encode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


oct_sqf_external_field_decode(p, sAcc, i, sInternalItem, noSizeMin, nSizeMax, sExtFld, nAlignSize, sErrCode, nIntItemMinSize, nIntItemMaxSize) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <if(noSizeMin)><noSizeMin>\<=<sExtFld> AND <endif><sExtFld>\<=<nSizeMax>, ErrorCode => <sErrCode>);
IF result.Success THEN
    <p>.Length := Integer(<sExtFld>);
    <loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
END IF;
>>


bit_oct_sqf_external_field_encode(sTasName, p, i, sInternalItem, nSizeMin, nSizeMax, nIntItemMinSize, nIntItemMaxSize, sExtFld, nAlignSize) ::= <<
<loopFixedItem_enc(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
>>


bit_oct_sqf_external_field_decode(sTasName, p, i, sInternalItem, nSizeMin, nSizeMax, nIntItemMinSize, nIntItemMaxSize, sExtFld, nAlignSize) ::= <<
val := <sTasName>_Init;
result := <rtlModuleName()>.ASN1_RESULT'(Success => <nSizeMin>\<=<sExtFld> AND <sExtFld>\<=<nSizeMax>, ErrorCode => 0);
IF result.Success THEN
    <p>.Length := Integer(<sExtFld>);
    <loopFixedItem_dec(i=i, sInternalItem=sInternalItem, fixedSize=[p,".Length"], nfixedSizeUperLimit = nSizeMax, nCurOffset="0", nAlignSize=nAlignSize, nIntItemMinSize=nIntItemMinSize, nIntItemMaxSize=nIntItemMaxSize)>
END IF;
>>


RefTypeParam_tmpVar(sName, sTypeDecl) ::= "<sName>:<sTypeDecl>;"

ReferenceType1_encode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>;-- 3031<endif>}; separator="\n">
<sName>_ACN_Encode_aux(<p>, S, K<if(bAcnEncodeFuncRequiresResult)>, result<endif><if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>

ReferenceType1_decode(p, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= <<
<arrsLocalPrms, arrsArgs: {lp,arg|<if(arg)><lp> := <arg>; -- 3030<endif>}; separator="\n">
<sName>_ACN_Decode_aux(<p>, S, K, result<if(arrsArgs)>, <arrsLocalPrms; separator=", "><endif>);
>>

ReferenceType2_encode(p, sTasName, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= "<sTasName>.<ReferenceType1_encode(p=p, sName=sName, bAcnEncodeFuncRequiresResult = bAcnEncodeFuncRequiresResult, arrsArgs=arrsArgs, arrsLocalPrms=arrsLocalPrms)>"

ReferenceType2_decode(p, sTasName, sName, bAcnEncodeFuncRequiresResult, arrsArgs, arrsLocalPrms) ::= "<sTasName>.<ReferenceType1_decode(p=p, sName=sName, bAcnEncodeFuncRequiresResult = bAcnEncodeFuncRequiresResult, arrsArgs=arrsArgs, arrsLocalPrms=arrsLocalPrms)>"


/* SEQUENCE*/

sequence_presense_optChild_encode(p, sAcc, sChName, sErrCode) ::= "<rtlModuleName()>.BitStream_AppendBit(S, K,<p>.Exist.<sChName>);"
sequence_presense_optChild_decode(p, sAcc, sChName, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
<rtlModuleName()>.BitStream_ReadBit(S, K,<p>.Exist.<sChName>, result.Success);
>>

sequence_presense_optChild_pres_bool_encode(p, sAcc, sChName, sExtFldName) ::= ""
sequence_presense_optChild_pres_bool_decode(p, sAcc, sChName, sExtFldName) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> then 1 else 0);
result.Success := true;
>>

sequence_presense_optChild_pres_int_encode(p, sAcc, sChName, sExtFldName, nIntVal) ::= ""
sequence_presense_optChild_pres_int_decode(p, sAcc, sChName, sExtFldName, nIntVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = <nIntVal> then 1 else 0);
result.Success := true;
>>

sequence_presense_optChild_pres_str_encode(p, sAcc, sChName, sExtFldName, sVal) ::= ""
sequence_presense_optChild_pres_str_decode(p, sAcc, sChName, sExtFldName, sVal) ::= <<
<p>.Exist.<sChName> := (if <sExtFldName> = "<nIntVal>" then 1 else 0);
result.Success := true;
>>

sequence_acn_child_encode(sChName, sChildContent, sErrCode) ::= <<
--Encode <sChName> 
if <sChName>_is_initialized then
    result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);
    <sChildContent>
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
end if;
>>
sequence_acn_child_decode(sChName, sChildContent, sErrCode) ::= <<
--Decode <sChName> 
<sChildContent>
>>


sequence_mandatory_child_encode(sChName, sChildContent) ::= <<
-- Encode <sChName> 
<sChildContent>
>>
sequence_mandatory_child_decode(sChName, sChildContent) ::= <<
-- Decode <sChName> 
<sChildContent>
>>

sequence_optional_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>

sequence_optional_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
end if;
>>


sequence_optional_always_present_child_encode(p, sAcc, sChName, sChildContent) ::= <<
-- Encode <sChName> (always present, do not check for presence)
<sChildContent>
>>

sequence_optional_always_present_child_decode(p, sAcc, sChName, sChildContent) ::= <<
-- Decode <sChName> (always present, do not check for presence)
<p>.Exist.<sChName> := 1;
<sChildContent>
>>


sequence_default_child_encode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue) ::= <<
<sequence_optional_child_encode(p=p, sAcc=sAcc, sChName=sChName, sChildContent=sChildContent)>
>>


sequence_default_child_decode(p, sAcc, sChName, sChildContent, sInitWithDefaultValue) ::= <<
-- Decode <sChName>
if <p>.Exist.<sChName> = 1 then
	<sChildContent>
else
    <sInitWithDefaultValue>
end if;
>>




Sequence_encode(p, arrsChildren, sTasName, bRequiresInit, arrsDecOutParamsInit, bResultRequiresInit) ::= <<
<if(arrsChildren)>
<arrsChildren; separator="\n">

<else>
null;

<endif>
>>


PrmUpdate(sPrmName, sPrmInitValue) ::= "<sPrmName> := <sPrmInitValue>;"

Sequence_decode(p, arrsChildren, sTasName, bRequiresInit, arrsDecOutParamsInit, bResultRequiresInit) ::= <<
<if(bRequiresInit)>val := <sTasName>_Init;<endif>
<arrsDecOutParamsInit; separator="\n">
<if(bResultRequiresInit)>
result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);

<endif>
<arrsChildren; separator="\n">
>>



JoinItems_encode(sTasName, sPart, sNestedPart, nRequiredBitsSoFar, bRequiresAssert,  bReqResultCheck) ::= <<
<sPart>
<if(sNestedPart)>
<if(bRequiresAssert)>
--# assert K~+1>= S'First and K~ + <sTasName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last AND
--#	       K>=K~ and K\<=K~+<nRequiredBitsSoFar>;

<endif>
<if(bReqResultCheck)>
IF result.Success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>


UpdateFailedPart()::="result.ErrorCode := <rtlModuleName()>.ERR_INCORRECT_DATA;"

JoinItems_decode(sTasName, sPart, sNestedPart, nRequiredBitsSoFar, bRequiresAssert, bReqResultCheck) ::= <<
<sPart>
<if(sNestedPart)>
<if(bRequiresAssert)>
--# assert K~.K+1>= S'First and K~.K + <sTasName>_REQUIRED_BITS_FOR_ACN_ENCODING \<= S'Last AND
--#	       K.K>=K~.K and K.K\<=K~.K+<nRequiredBitsSoFar>;	

<endif>
<if(bReqResultCheck)>
IF result.Success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>


/* Choice like uper*/

Choice_encode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, sChoiceTypeDef, nIndexSizeInBits, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

Choice_decode(p, sAcc, arrsChildren, nLastItemIndex, sChoiceIndexName, sChoiceTypeDef, nIndexSizeInBits, sErrCode) ::= <<
result.ErrorCode := <sErrCode>;
<rtlModuleName()>.UPER_Dec_ConstraintWholeNumber(S, K, <sChoiceIndexName>, 0, <nLastItemIndex>, <nIndexSizeInBits>, result.Success);
if result.Success AND <sChoiceIndexName> \>= 0 AND  <sChoiceIndexName> \<= <nLastItemIndex> THEN
    case <sChoiceTypeDef>_index_range(<sChoiceIndexName>) IS
        <arrsChildren; separator="\n">
    end case;
end if;
>>

ChoiceChildAlwaysAbsent_encode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <sChildID> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);
>>

ChoiceChildAlwaysAbsent_decode(p, sAcc, sChildID, nChildIndex, sErrorCodeName) ::= <<
when <nChildIndex> =>
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrorCodeName>);
>>


ChoiceChild_encode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
    <rtlModuleName()>.UPER_Enc_ConstraintWholeNumber(S, K, <nChildIndex>, 0, <nIndexSizeInBits>);
	<sChildContent>
>>

ChoiceChild_decode(p, sAcc, sChildID, nChildIndex, nIndexSizeInBits, nLastItemIndex, sChildContent, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <nChildIndex> =>
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildContent>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>

/* Choice with Enum determinant */

ChoiceChild_Enum_encode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
	<sChildBody>
>>

ChoiceChild_Enum_decode(p, sAcc, sEnmName, sChildID, sChildBody, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sEnmName> =>
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildBody>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>

Choice_Enum_encode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

Choice_Enum_decode(p, sAcc, arrsChildren, sEnmExtFld, sErrCode) ::= <<
case <sEnmExtFld> IS
    <arrsChildren; separator="\n">
end case;
>>




/* Choice with presense determinants */


ChoiceChild_preWhen_bool_condition(sExtFld) ::= "<sExtFld>"
ChoiceChild_preWhen_int_condition(sExtFld, nVal) ::= "(<sExtFld> = <nVal>)"
ChoiceChild_preWhen_str_condition(sExtFld, sVal) ::= "(<sExtFld> = \"<sVal>\""

Choice_preWhen_encode(p, sAcc, arrsChildren, sErrCode) ::= <<
case <p><sAcc>kind IS
    <arrsChildren; separator="\n">
end case;
>>

ChoiceChild_preWhen_encode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
when <sChildID> =>
	<sChildBody>
>>



Choice_preWhen_decode(p, sAcc, arrsChildren, sErrCode) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => true, ErrorCode => 0);
<arrsChildren; separator="\n">
else
    result := <rtlModuleName()>.ASN1_RESULT'(Success => false, ErrorCode => <sErrCode>); 
end if;
>>

ChoiceChild_preWhen_decode(p, sAcc, sChildID, sChildBody, arrsConditions, bFirst, sChildName, sChildTypeDef, sChoiceTypeName) ::= <<
<if(bFirst)>if<else>elsif<endif> (<arrsConditions; separator=" and ">) then
  declare
     <sChildName>_tmp:<sChildTypeDef>;
  begin
    <sChildBody>
    if result.Success then
        <p> := <sChoiceTypeName>'(kind => <sChildID>, <sChildName> => <sChildName>_tmp);
        pragma Annotate (GNATprove, False_Positive,"discriminant check might fail", "reviewed by GM");
    end if;
  end;
>>





ChoiceChild_tmpVar(sName, sTypeDecl) ::= "<sName>_tmp:<sTypeDecl>;"


Declare_ChoiceIndex()::="index:<rtlModuleName()>.Asn1Int;"



/* Updates */


MultiAcnUpdate_checkEqual_pri0(p1,p2) ::= "(<p1> = <p2>)"
MultiAcnUpdate_checkEqual_str0(p1,p2) ::= "(<p1> = <p2>)"

MultiAcnUpdate_get_first_init_value_pri(sV0, sVi, bIsFirst) ::= <<
<if(bIsFirst)>if<else>elsif<endif> <sVi>_is_initialized then
    <sV0> := <sVi>;
>>

MultiAcnUpdate_get_first_init_value_str(sV0, sVi, bIsFirst) ::= <<
<MultiAcnUpdate_get_first_init_value_pri(sV0=sV0, sVi=sVi, bIsFirst=bIsFirst)>
>>

MultiAcnUpdate_checkEqual_pri(sV0, sVi) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"
MultiAcnUpdate_checkEqual_str(sV0, sVi) ::= "((<sVi>_is_initialized and <sV0> = <sVi>) or not <sVi>_is_initialized)"

MultiAcnUpdate(v, v0, sErrCode, arrsLocalDeclarations, arrsLocalUpdateStatements, arrsGetFirstIntValue, arrsLocalCheckEquality) ::= <<
declare
    <arrsLocalDeclarations; separator="\n">
begin
    
    <arrsLocalUpdateStatements; separator="\n">
    
    <arrsGetFirstIntValue; separator="\n"> 
    else 
        result := <rtlModuleName()>.ASN1_RESULT'(Success => False, ErrorCode => <sErrCode>);
    end if;

    result := <rtlModuleName()>.ASN1_RESULT'(Success => result.Success and (<arrsLocalCheckEquality; separator=" and ">), ErrorCode => <sErrCode>);
    <v>_is_initialized := result.Success;
end;
>>




PresenceDependency(v, sSeqPath, sAcc, sChildName) ::= <<
<v>_is_initialized := TRUE;
<v> := (<sSeqPath><sAcc>exist.<sChildName> = 1);
>>




SizeDependency(v, sCount) ::= <<
<v>_is_initialized := TRUE;
<v> := <rtlModuleName()>.Asn1UInt(<sCount>);
>>


getStringSize(p) ::= "<rtlModuleName()>.getStringSize(<p>)"
getSizeableSize(p, sAcc) ::= "<p>.Length"



ChoiceDependencyPres(sChPath, sAcc, arrsChoiceItems) ::= <<
case <sChPath><sAcc>kind IS
    <arrsChoiceItems; separator="\n">
end case;
>>

ChoiceDependencyIntPres_child(v, sChildNamePrese, nChildRetVal) ::= <<
when <sChildNamePrese> =>
    <v>_is_initialized := TRUE;
	<v> := <nChildRetVal>; 
>>

ChoiceDependencyStrPres_child(v, sChildNamePrese, sChildRetVal) ::= <<
when <sChildNamePrese> =>
    <v>_is_initialized := TRUE;
	<v> := "<nChildRetVal>"; 
>>



ChoiceDependencyEnum_Item(v, sChildCID, sEnumCName) ::= <<
when <sChildCID> =>
    <v>_is_initialized := TRUE;
	<v> := <sEnumCName>; 
>>

ChoiceDependencyEnum(sChPath, sAcc, arrsChoiceEnumItems) ::= <<
case <sChPath><sAcc>kind IS
    <arrsChoiceEnumItems; separator="\n">
end case;
>>



checkAccessPath(arrsCheckPaths, sUpdateStatement) ::= <<
if (<arrsCheckPaths; separator=" && ">) then
    <sUpdateStatement>
end if;
>>




















PrintAcn_update_param(sTasName, bHasSuccess, sParamName, sContent, sParamType, arrsTmpVars) ::= <<
PROCEDURE <sTasName>_ACN_Encode_update_<sParamName>(val : IN <sTasName>; <sParamName>: OUT <sParamType><if(bHasSuccess)>; result : OUT <rtlModuleName()>.ASN1_RESULT<endif>)
---# derives <sParamName><if(bHasSuccess)>, result<endif> from val;
IS
    <arrsTmpVars; separator="\n">
BEGIN
    <sContent>
END <sTasName>_ACN_Encode_update_<sParamName>;
>>

PrintAcn_update_param_body_choice_child(sChildName, sChildUpdateStatement, bCheckSuccess, sChildNamePresent) ::= <<
WHEN <sChildNamePresent> =>	
    <sChildUpdateStatement>
<if(!bCheckSuccess)>    result := <rtlModuleName()>.ASN1_RESULT'(Success => TRUE, ErrorCode => 0);<endif>
>>

PrintAcn_update_param_body_choice(sTasName, arrsChildUpdateStatements) ::= <<
CASE <sTasName>_kind(val) IS
	<arrsChildUpdateStatements; separator="\n">
END CASE;
>>

PrintAcn_update_param_body(sPart, sNestedPart, bCheckSuccess) ::= <<
<sPart>
<if(sNestedPart)>
<if(bCheckSuccess)>
IF result.success THEN
    <sNestedPart>
END IF;
<else>
<sNestedPart>
<endif>
<endif>
>>



RefTypeArgument1(v, sTasName, sParamName, sRefTypePath, bHasSuccess) ::= <<
<sTasName>_ACN_Encode_update_<sParamName>(<sRefTypePath>, <v><if(bHasSuccess)>, result<endif>);
>>

RefTypeArgument2(v, sModName, sTasName, sParamName, sRefTypePath, bHasSuccess) ::= <<
<sModName>.<RefTypeArgument1(v=v, sTasName=sTasName, sParamName=sParamName, sRefTypePath=sRefTypePath, bHasSuccess=bHasSuccess)>
>>



MultiUpdateCheckWithFirstValue(sCurValue, sFirstValue) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sCurValue> = <sFirstValue>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>

MultiUpdateCheckWithFirstValueInteger(sCurValue, sFirstValue) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sCurValue> = <sFirstValue>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>

MultiParamUpdateCheckWithFirstValue(sCurValue, sFirstValue) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sCurValue> = <sFirstValue>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>

CheckBeforeAssignToIntField_min_max(sTmpVar0, nMin, nMax) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sTmpVar0> >= <nMin> AND <sTmpVar0>\<=<nMax>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>
CheckBeforeAssignToIntField_max(sTmpVar0, nMax) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sTmpVar0>\<=<nMax>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>
CheckBeforeAssignToIntField_min(sTmpVar0, nMin) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => <sTmpVar0> >= <nMin>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>

UpdateAsn1Field(sAcnField, sTmpVar) ::= <<
<sAcnField> := <sTmpVar>; -- 23945
>>


UpdateAsn1IntegerField(sAcnField, sTmpVar0, sAsn1FieldType) ::= <<
<sAcnField> := <sTmpVar0>; -- 23946
>>


MultiUpdateCheckWithFirstValue2(sCurValue, sFirstValue) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => result.success AND <sCurValue> = <sFirstValue>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>

MultiParamUpdateCheckWithFirstValue2(sCurValue, sFirstValue) ::= <<
result := <rtlModuleName()>.ASN1_RESULT'(Success => result.success AND <sCurValue> = <sFirstValue>, ErrorCode => <rtlModuleName()>.ERR_INCORRECT_DATA);
>>


