module CAstAcnEncodingClasses


open System
open System.Numerics
open Constraints
open CAst
open FsUtils



let rec GetAlignment (acnProps: AcnTypes.AcnProperty list)  =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.Aligment(al) -> Some al | _ -> None ) with
    | hd::hx   -> Some hd
    | []       -> None

let rec GetBooleanEncoding (acnProps: AcnTypes.AcnProperty list)  =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.BooleanEncoding(a) -> Some a | _ -> None ) with
    | hd::_   -> hd
    | []      -> AcnTypes.TrueValue "1".AsLoc


let rec GetNullEncodingValue (acnProps: AcnTypes.AcnProperty list)   =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.NullValue(a) -> Some a | _ -> None ) with
    | hd::_   -> Some hd.Value
    | []      -> None

let rec GetEndianess (acnProps: AcnTypes.AcnProperty list)   =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.Endianness(a) -> Some a | _ -> None ) with
    | hd::_   -> hd
    | []      -> AcnTypes.endianness.BigEndianness


let rec isEnumEncodingValues (acnProps: AcnTypes.AcnProperty list)   =
    acnProps |> List.exists(fun x -> match x with AcnTypes.EncodeValues -> true | _ -> false ) 

let GetEncodingProperty (acnProps: AcnTypes.AcnProperty list) =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.Encoding(a) -> Some a | _ -> None ) with
    | hd::_ -> Some hd
    | []    -> None



type sizePropertyPriv =
    | SP_Fixed          of int
    | SP_NullTerminated of byte


///helper function
let sizeToPriv (constants:AcnTypes.AcnConstant list)  sizeProperty =
    match sizeProperty with
    | AcnTypes.sizeProperty.Fixed(c)            -> SP_Fixed (int (AcnTypes.EvaluateConstant constants c))
    | AcnTypes.sizeProperty.NullTerminated  b    -> SP_NullTerminated b

let GetSizeProperty  (constants:AcnTypes.AcnConstant list) (acnProps: AcnTypes.AcnProperty list) =
    match acnProps |> List.choose(fun x -> match x with AcnTypes.SizeProperty(a) -> Some a | _ -> None ) with     
    | hd::_ -> (sizeToPriv constants hd )
    | []    -> raise(BugErrorException "mandatory property missing")


let getAcnProps (acnTypes:Map<AcnTypes.AbsPath,AcnTypes.AcnType>) (typeId:ReferenceToType) = 
    let acnKey = typeId.AcnAbsPath
    match acnTypes.TryFind acnKey with
    | None  -> []
    | Some t -> t.Properties


//The banner was generated by the followin url    
//http://patorjk.com/software/taag/#p=display&h=2&v=1&f=Banner&t=Integer

(*
 ###                                          
  #  #    # ##### ######  ####  ###### #####  
  #  ##   #   #   #      #    # #      #    # 
  #  # #  #   #   #####  #      #####  #    # 
  #  #  # #   #   #      #  ### #      #####  
  #  #   ##   #   #      #    # #      #   #  
 ### #    #   #   ######  ####  ###### #    # 
*)

let GetIntEncodingClass (acn:AcnTypes.AcnAst)  (acnTypes:Map<AcnTypes.AbsPath,AcnTypes.AcnType>) errLoc (a:BAst.Integer) =
    let acnProps = getAcnProps acnTypes a.id
    let encClass, minSizeInBits, maxSizeInBits = 
        // if the mandatory property size is missing => the type will be encoded like uPER        
        match acnProps |> List.exists(fun x -> match x with AcnTypes.SizeProperty(_) -> true | _ -> false ) with     
        | false -> Integer_uPER, a.uperMinSizeInBits, a.uperMaxSizeInBits
        | true  -> 
            let endianess = GetEndianess acnProps
            let encProp = (GetEncodingProperty acnProps).Value
            let sizeProp = GetSizeProperty acn.Constants acnProps
            let bUINT = a.IsUnsigned

            match encProp, sizeProp, endianess with
            | AcnTypes.PosInt, SP_Fixed(8) , AcnTypes.BigEndianness               ->  PositiveInteger_ConstSize_8, 8, 8
            | AcnTypes.PosInt, SP_Fixed(16), AcnTypes.BigEndianness               ->  PositiveInteger_ConstSize_big_endian_16, 16, 16
            | AcnTypes.PosInt, SP_Fixed(16), AcnTypes.LittleEndianness            ->  PositiveInteger_ConstSize_little_endian_16, 16, 16
            | AcnTypes.PosInt, SP_Fixed(32), AcnTypes.BigEndianness               ->  PositiveInteger_ConstSize_big_endian_32, 32, 32
            | AcnTypes.PosInt, SP_Fixed(32), AcnTypes.LittleEndianness            ->  PositiveInteger_ConstSize_little_endian_32, 32, 32
            | AcnTypes.PosInt, SP_Fixed(64), AcnTypes.BigEndianness               ->  PositiveInteger_ConstSize_big_endian_64, 64, 64
            | AcnTypes.PosInt, SP_Fixed(64), AcnTypes.LittleEndianness            ->  PositiveInteger_ConstSize_little_endian_64, 64, 64
            | AcnTypes.PosInt, SP_Fixed(fxVal) , AcnTypes.BigEndianness           ->  PositiveInteger_ConstSize fxVal, fxVal, fxVal
            | AcnTypes.PosInt, SP_NullTerminated _, _                    ->  raise(SemanticError(errLoc, "Acn properties pos-int and null-terminated are mutually exclusive"))
            | AcnTypes.TwosComplement, _,_              when bUINT       ->  raise(SemanticError(errLoc, "Acn property twos-complement cannot be applied to non negative INTEGER types"))
            | AcnTypes.TwosComplement, SP_Fixed(8) , AcnTypes.BigEndianness       ->  TwosComplement_ConstSize_8, 8, 8
            | AcnTypes.TwosComplement, SP_Fixed(16), AcnTypes.BigEndianness       ->  TwosComplement_ConstSize_big_endian_16, 16, 16
            | AcnTypes.TwosComplement, SP_Fixed(16), AcnTypes.LittleEndianness    ->  TwosComplement_ConstSize_little_endian_16, 16, 16
            | AcnTypes.TwosComplement, SP_Fixed(32), AcnTypes.BigEndianness       ->  TwosComplement_ConstSize_big_endian_32, 32, 32
            | AcnTypes.TwosComplement, SP_Fixed(32), AcnTypes.LittleEndianness    ->  TwosComplement_ConstSize_little_endian_32, 32, 32
            | AcnTypes.TwosComplement, SP_Fixed(64), AcnTypes.BigEndianness       ->  TwosComplement_ConstSize_big_endian_64, 64, 64
            | AcnTypes.TwosComplement, SP_Fixed(64), AcnTypes.LittleEndianness    ->  TwosComplement_ConstSize_little_endian_64, 64, 64
            | AcnTypes.TwosComplement, SP_Fixed(fxVal) , AcnTypes.BigEndianness   ->  TwosComplement_ConstSize fxVal, fxVal, fxVal
            | AcnTypes.TwosComplement, SP_NullTerminated _, _            ->  raise(SemanticError(errLoc, "Acn properties twos-complement and null-terminated are mutually exclusive"))
            | AcnTypes.Ascii, SP_Fixed(fxVal) , AcnTypes.BigEndianness            ->  
                match bUINT with
                | true                                                            -> ASCII_UINT_ConstSize fxVal, fxVal, fxVal
                | false                                                           -> ASCII_ConstSize  fxVal, fxVal, fxVal
            | AcnTypes.BCD, SP_Fixed(fxVal) , AcnTypes.BigEndianness              ->  BCD_ConstSize fxVal, fxVal, fxVal
            | AcnTypes.BCD, SP_NullTerminated b, AcnTypes.BigEndianness           ->  BCD_VarSize_NullTerminated b, 4, 19*4
            | AcnTypes.Ascii, SP_NullTerminated b, AcnTypes.BigEndianness         ->  
                match bUINT with
                | true                                                            -> ASCII_UINT_VarSize_NullTerminated b, 8, 8+8+18*8
                | false                                                           -> ASCII_VarSize_NullTerminated b, 8, 8+8+18*8
            | _, SP_NullTerminated _, _                                  ->  raise(SemanticError(errLoc, "null-terminated can be applied only for ASCII or BCD encodings"))
            | _, _ , AcnTypes.LittleEndianness                           ->  raise(SemanticError(errLoc, "Little endian can be applied only for fixed size encodings and size must be 16 or 32 or 64"))
            | AcnTypes.IEEE754_32, _, AcnTypes.BigEndianness             ->  raise(SemanticError(errLoc, "invalid encoding value (choose one of pos-int, twos-complement, ascii, BCD)"))
            | AcnTypes.IEEE754_64, _, AcnTypes.BigEndianness             ->  raise(SemanticError(errLoc, "invalid encoding value (choose one of pos-int, twos-complement, ascii, BCD)"))

    encClass, minSizeInBits, maxSizeInBits
(*
 ######                       
 #     # ######   ##   #      
 #     # #       #  #  #      
 ######  #####  #    # #      
 #   #   #      ###### #      
 #    #  #      #    # #      
 #     # ###### #    # ###### 
                              
*)

let GetRealEncodingClass (acn:AcnTypes.AcnAst)  (acnTypes:Map<AcnTypes.AbsPath,AcnTypes.AcnType>) errLoc (a:BAst.Real) =
    let acnProps = getAcnProps acnTypes a.id
    let encClass, minSizeInBits, maxSizeInBits = 
        match acnProps |> List.exists(fun x -> match x with AcnTypes.Encoding(_) -> true | _ -> false ) with     
        | false     -> Real_uPER, a.uperMinSizeInBits, a.uperMaxSizeInBits
        | true      ->
            let enc = (GetEncodingProperty acnProps).Value
            let endianess = GetEndianess acnProps
            match enc, endianess with
            | AcnTypes.IEEE754_32, AcnTypes.BigEndianness     -> Real_IEEE754_32_big_endian, 32, 32
            | AcnTypes.IEEE754_64, AcnTypes.BigEndianness     -> Real_IEEE754_64_big_endian, 64, 64
            | AcnTypes.IEEE754_32, AcnTypes.LittleEndianness  -> Real_IEEE754_32_little_endian, 32, 32
            | AcnTypes.IEEE754_64, AcnTypes.LittleEndianness  -> Real_IEEE754_64_little_endian, 64, 64
            | _,_                                             -> raise(BugErrorException "Invalid combination")
    encClass, minSizeInBits, maxSizeInBits  

(*
 ###    #    #######  #####                               
  #    # #   #       #     # ##### #####  # #    #  ####  
  #   #   #  #       #         #   #    # # ##   # #    # 
  #  #     # ######   #####    #   #    # # # #  # #      
  #  #######       #       #   #   #####  # #  # # #  ### 
  #  #     # #     # #     #   #   #   #  # #   ## #    # 
 ### #     #  #####   #####    #   #    # # #    #  ####  
*)


type PrivateSizeableEncodingClass =
    | PrivateFixedSize of int
    | PrivateAutoSize  
    | PrivateExternalField of IntegerDeterminant
    | PrivateNullTerminated of byte


let GetStringEncodingClass (acn:AcnTypes.AcnAst)  (acnTypes:Map<AcnTypes.AbsPath,AcnTypes.AcnType>) errLoc (a:BAst.StringType) (tasInfo: AcnTypeAssignmentInfo<IntParameter> option) =
    let asn1Min, asn1Max = a.minSize, a.maxSize
    let acnProps = getAcnProps acnTypes a.id
    let bAsn1FixedSize = asn1Min = asn1Max
    let bAsciiEncoding =
        match GetEncodingProperty acnProps with
        | Some AcnTypes.Ascii     -> true
        | _                       -> false
    let acnParams = tasInfo |> Option.map(fun t -> t.ancParameters) |> Option.toList |> List.collect id
        
    let sizeClass = 
        match acnProps |> List.choose(fun x -> match x with AcnTypes.SizeProperty(a) -> Some a | _ -> None ) with     
        | hd::_ -> 
            match hd with
            | AcnTypes.sizeProperty.Fixed(c)            -> PrivateFixedSize (int (AcnTypes.EvaluateConstant acn.Constants c))
            | AcnTypes.sizeProperty.NullTerminated b    -> PrivateNullTerminated b
        | []    -> 
            match acn.References |> Seq.tryFind(fun x -> x.TypeID = a.id.AcnAbsPath && x.Kind = AcnTypes.SizeDeterminant) with
            | Some(r)       ->  
                let determinant : IntegerDeterminant =
                    let parentId = a.id.parentTypeId
                    let determinantId childRelPath = 
                        let determinantId = parentId |> Option.map (fun x -> x.appendLongChildId childRelPath)
                        match determinantId with
                        | None                  -> raise(SemanticError (r.Location, sprintf "Invalid Reference '%s'" (r.LongRef.ToString()) ))
                        | Some determinantId    -> AcnIntroducedType determinantId
                    match r.LongRef with
                    | []            -> raise(SemanticError (r.Location,"Invalid Reference (empty path)" ))
                    | fldName::[]   ->
                        match acnParams |> Seq.tryFind(fun p -> p.name = fldName) with
                        | Some p    -> AcnPrmType p
                        | None      -> determinantId r.LongRef
                    | _             -> determinantId r.LongRef
                PrivateExternalField determinant
            | None          ->  PrivateAutoSize

    let alphaSet = a.charSet
    let allowedBytes = alphaSet |> Array.map(fun c -> (System.Text.Encoding.ASCII.GetBytes (c.ToString())).[0]) |> Set.ofArray
    let lengthDeterminantSize = GetNumberOfBitsForNonNegativeInt (asn1Max-asn1Min)
    let charSizeInBits =
        match  bAsciiEncoding with
        | true      -> 8
        | false     -> GetNumberOfBitsForNonNegativeInt (alphaSet.Length - 1)
    let encClass, minSizeInBits, maxSizeInBits = 
        match  bAsciiEncoding, bAsn1FixedSize, sizeClass  with
        | true, true, PrivateAutoSize                                          -> Acn_Enc_String_Ascii_FixSize asn1Max, asn1Max*charSizeInBits,  asn1Max*charSizeInBits
        | true, true, PrivateNullTerminated  b                                 -> 
            match allowedBytes.Contains b && (not (b=0uy && alphaSet.Length = 128))with
            | true  -> raise(SemanticError(errLoc, "The termination-pattern defines a character which belongs to the allowed values of the ASN.1 type. Use another value in the termination-pattern or apply different constraints in the ASN.1 type."))
            | false -> Acn_Enc_String_Ascii_Null_Teminated b, (asn1Max+1)*charSizeInBits, (asn1Max+1)*charSizeInBits
        | true, true, PrivateFixedSize(nItems)    when nItems = asn1Max        -> Acn_Enc_String_Ascii_FixSize asn1Max, asn1Max*charSizeInBits,  asn1Max*charSizeInBits
        | true, true, PrivateFixedSize(nItems)                                 -> raise(BugErrorException(sprintf "size property value should be set to %A" asn1Max))
        | true, true, PrivateExternalField fld                                 -> Acn_Enc_String_Ascii_External_Field_Determinant fld, asn1Max*charSizeInBits,  asn1Max*charSizeInBits

        | true, false, PrivateAutoSize                                         -> Acn_Enc_String_Ascii_Internal_Field_Determinant lengthDeterminantSize, lengthDeterminantSize + asn1Min*charSizeInBits, lengthDeterminantSize + asn1Max*charSizeInBits
        | true, false, PrivateNullTerminated b                                 -> 
            match allowedBytes.Contains b && (not (b=0uy && alphaSet.Length = 128))with
            | true  -> raise(SemanticError(errLoc, "The termination-pattern defines a character which belongs to the allowed values of the ASN.1 type. Use another value in the termination-pattern or apply different constraints in the ASN.1 type."))
            | false -> Acn_Enc_String_Ascii_Null_Teminated b, (asn1Max+1)*charSizeInBits, (asn1Max+1)*charSizeInBits
        | true, false, PrivateFixedSize(nItems)                                -> raise(BugErrorException(sprintf "The size constraints of the ASN.1  allows variable items (%A .. %A). Therefore, you should either remove the size property (in which case the size determinant will be encoded automatically exactly like uPER), or use a an Integer field as size determinant" asn1Min asn1Max))
        | true, false, PrivateExternalField fld                                -> Acn_Enc_String_Ascii_External_Field_Determinant fld, asn1Max*charSizeInBits,  asn1Max*charSizeInBits

        | false, true, PrivateAutoSize                                         -> Acn_Enc_String_CharIndex_FixSize asn1Max, asn1Max*charSizeInBits,  asn1Max*charSizeInBits 
        | false, true, PrivateNullTerminated  _                                -> raise(BugErrorException(sprintf "when a string type has the acn property 'size null-terminated' it must also have the acn property 'encoding ASCII'" ))
        | false, true, PrivateFixedSize(nItems)    when nItems = asn1Max       -> Acn_Enc_String_CharIndex_FixSize asn1Max, asn1Max*charSizeInBits,  asn1Max*charSizeInBits
        | false, true, PrivateFixedSize(nItems)                                -> raise(BugErrorException(sprintf "size property value should be set to %A" asn1Max))
        | false, true, PrivateExternalField fld                                -> Acn_Enc_String_CharIndex_External_Field_Determinant fld, asn1Max*charSizeInBits,  asn1Max*charSizeInBits

        | false, false, PrivateAutoSize                                        -> Acn_Enc_String_CharIndex_Internal_Field_Determinant lengthDeterminantSize, lengthDeterminantSize + asn1Min*charSizeInBits, lengthDeterminantSize + asn1Max*charSizeInBits
        | false, false, PrivateNullTerminated  _                               -> raise(BugErrorException(sprintf "when a string type has the acn property 'size null-terminated' it must also have the acn property 'encoding ASCII'" ))
        | false, false, PrivateFixedSize(nItems)                               -> raise(BugErrorException(sprintf "The size constraints of the ASN.1  allows variable items (%A .. %A). Therefore, you should either remove the size property (in which case the size determinant will be encoded automatically exactly like uPER), or use a an Integer field as size determinant" asn1Min asn1Max))
        | false, false, PrivateExternalField fld                               -> Acn_Enc_String_CharIndex_External_Field_Determinant fld, asn1Min*charSizeInBits, asn1Max*charSizeInBits

    encClass, minSizeInBits, maxSizeInBits

//banner text from this link
//http://patorjk.com/software/taag/#p=display&v=2&f=ANSI%20Shadow&t=Octet%20String%0A
(*
 ██████╗  ██████╗████████╗███████╗████████╗    ███████╗████████╗██████╗ ██╗███╗   ██╗ ██████╗ 
██╔═══██╗██╔════╝╚══██╔══╝██╔════╝╚══██╔══╝    ██╔════╝╚══██╔══╝██╔══██╗██║████╗  ██║██╔════╝ 
██║   ██║██║        ██║   █████╗     ██║       ███████╗   ██║   ██████╔╝██║██╔██╗ ██║██║  ███╗
██║   ██║██║        ██║   ██╔══╝     ██║       ╚════██║   ██║   ██╔══██╗██║██║╚██╗██║██║   ██║
╚██████╔╝╚██████╗   ██║   ███████╗   ██║       ███████║   ██║   ██║  ██║██║██║ ╚████║╚██████╔╝
 ╚═════╝  ╚═════╝   ╚═╝   ╚══════╝   ╚═╝       ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ 
                                                                                              
*)
//let GetOctetStringEncodingClass (acn:AcnTypes.AcnAst)  (acnTypes:Map<AcnTypes.AbsPath,AcnTypes.AcnType>) errLoc (a:BAst.StringType) (tasInfo: AcnTypeAssignmentInfo<IntParameter> option) =
