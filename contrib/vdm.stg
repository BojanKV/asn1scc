group vdm;

//delimiters "$", "$"


/* Header of the file */
RootXml(arrsFiles) ::= <<
$arrsFiles;separator="\n"$
>>


/* sFileName is a string with the current file name */
FileXml(sFileName, arrsModules) ::= <<
$arrsModules;separator="\n"$
>>


/* Per ASN.1 module. you can use:
  - the module name ($sName$)
  - the list of types that are exported by this module.
    Example of use:
    $arrsExpTypes:{x|"$x$"};separator=", "$
  - the list of variables that are exported by this module (arrsExpVars)
  - the list of imported modules (generated by template ImportedMod)
 Then you can use the list of types and variables defined in this module
 arrsTases is an array of strings generated by template TasXml
 arrsVases is an array of strings generated by template VasXml
*/
ModuleXml(sName, arrsImportedModules, arrsExpTypes, arrsExpVars, arrsTases, arrsVases) ::=<<
$arrsTases;separator="\n"$

$arrsVases;separator="\n"$
>>


/* An imported module with a list of imported types and variables */
ImportedMod(sName, arrsTypes, arrsVars) ::= <<
>>


/* A single Type Assignment, this is filled for all types of all modules */
/* Issue with VDM: depending on the type the separator may be "=" or "::" */
TasXml(sName, nLine, nPos, sType) ::= <<
-- Type $sName$ is defined at line $nLine$, position $nPos$
$sName$ = $sType$

>>


/* A single Variable Assignment */
VasXml(sName, nLine, nPos, sType) ::= <<
-- Variable $sName$ is defined at line $nLine$, position $nPos$,
dcl $sName$ : $sType$;
>>

TypeGeneric(nLine, nPos, sSubType) ::= <<
$sSubType$
>>

/* Type with Min and Max constraint. sName is the type kind
 (IntegerType, etc.) */
MinMaxType(sName, sMin, sMax) ::= <<
$sName$
>>

/* See MinMaxType */
MinMaxType2(sName, sMin, sMax) ::= <<
$sName$
>>

BooleanType () ::= "bool"

NullType () ::= "nil"

/* Enumerated item, note the difference between sName, which is the enumerated
   name given in the input type, for example if you have
   MyType ::= ENUMERATED { a, b, c } then sName can be a, b or c
   and sCID which is a name built by the parser for removing ambiguities in
   some languages, e.g. if you have two types with the same enumerated name:
   MyOtherType ::= ENUMERATED { b, x, y }
   When this case happens, sCID will be either "MyType_b" or "MyOtherType_b"
   Check if your language needs this or not (C does, Ada does not)
   note: the renaming policy can be controlled with the command line of asn1scc
   for VDM: assuming sCID, to be checked
   nVal is the integer value of the enumerated, use it if needed
*/
EnumItem (sName, nVal, nLine, nPos, sCID) ::= <<
<$sCID$>
>>

/* Enumerated type: arrsItems is an array of EnumItem */
EnumType(arrsItems) ::= <<
$arrsItems;separator=" | "$
>>


/* Choice field
   Choice are discriminated unions, they have a name per field and a type :
   MyCHOICE ::= CHOICE {
       choice-a   Type-of-A,   -- choice-a is sName
       choice-b   Type-of-B,
       ...
  }
  sNamePresent is an unambiguous name to access the field
*/
ChoiceChild(sName, nLine, nPos, sChildContent, sNamePresent ) ::= <<
$sChildContent$
>>

/* Full choice type: in VDM, should be <Type-of-A> | <Type-of-B> | ... */
ChoiceType(arrsChildren) ::= <<
$arrsChildren;separator=" | "$
>>


/* Sequence (record) field. May be optional and may have a default value */
SequenceChild(sName, bOptional, sDefVal, nLine, nPos, sChildContent ) ::= <<
$sName$ : $sChildContent$
>>

/* Full sequence (record) type */
SequenceType(arrsChildren) ::= <<
$arrsChildren;separator="\n"$
>>

/* Sequence of (array) */
SequenceOfType(sMin, sMax, sChild) ::= <<
seq of $sChild$
>>

/* Reference to another type, with Min/Max subtype
   Could be in a different module, check */
RefTypeMinMax(sMin, sMax, sName, sModName) ::= <<
$sName$
>>

/* Reference to another type */
RefType(sName, sModName) ::= <<
$sName$
>>
